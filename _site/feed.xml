<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-06-07T00:56:59+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Slow and Steady</title><subtitle>Data Science, Computer Science, Statistics, AI.</subtitle><author><name>Junhwan</name></author><entry><title type="html">[AL] 8. Space and Time Trade-Offs</title><link href="http://localhost:4000/computerscience/AL-8-Space-and-Time-Trade-Offs/" rel="alternate" type="text/html" title="[AL] 8. Space and Time Trade-Offs" /><published>2022-06-04T00:00:00+09:00</published><updated>2022-06-04T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/%5BAL%5D%208%20Space%20and%20Time%20Trade-Offs</id><content type="html" xml:base="http://localhost:4000/computerscience/AL-8-Space-and-Time-Trade-Offs/"><![CDATA[<blockquote>
  <p>Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin</p>
</blockquote>

<h1 id="space-and-time-trade-offs">Space and Time Trade-Offs</h1>
<p>두가지 종류의 space-for-time 알고리즘</p>
<ol>
  <li>Input enhancement
    <ul>
      <li>문제 해결을 가속화하기 위해 입력을 전처리하여 저장한다.</li>
      <li>Ex) countingn methods for sorting, string matching algorithms (Boyer-Moore algorithm and Horspool algorithm)</li>
    </ul>
  </li>
  <li>Prestructuring
    <ul>
      <li>데이터를 더 빠르고 유연하게 접근하기 위해 추가적인 공간을 사용한다.</li>
      <li>Ex) Hashing, indexing with B-trees</li>
    </ul>
  </li>
</ol>

<h2 id="counting-sort">Counting sort</h2>

<h3 id="comparison-counting-sort">Comparison-counting sort</h3>
<ul>
  <li>Input-enhancement technique</li>
  <li>정렬을 해야하는 각각의 원소에 대하여 그 원소보다 더 작은 원소의 갯수를 저장한다.</li>
  <li>이 숫자는 정렬된 리스트에서 그 원소의 위치를 나타낸다.
    <p align="center"><img src="/assets/img/[AL]8/comparisonsorting.png" width="70%" height="70%" /></p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM ComparisonCountingSort(A[0..n-1])
  //Sorts an array by comparison counting
  //Input: An array A[0..n-1] of orderable elements
  //Output: Array S[0..n-1] of A's elements sorted in nondecreasing order
      for i &lt;- 0 to n-1 do Count[i] &lt;- 0
      for i &lt;- 0 to n-2 do
          for j &lt;- i+1 to n-1 do
              if A[i] &lt; A[j]
                  Count[j] &lt;- Count[j] + 1
              else
                  Count[i] &lt;- Count[i] + 1
      for i &lt;- 0 to n-1 do S[Count[i]] &lt;- A[i]
      return S
</code></pre></div>    </div>
  </li>
  <li>The number of key comparison 
$$C(n)=\sum^{n-2}<em>{i=0}\sum^{n-1}</em>{j=i+1} 1 = \sum^{n-2}<em>{i=0}[(n-1)-(i+1)+1]=\sum^{n=2}</em>{i=0}(n-1-i) = {n(n-1) \over 2}</li>
  <li>선택정렬과 같은 횟수 만큼 key를 비교한다.</li>
  <li>입력의 크기만큼 추가 공간이 필요하다.</li>
  <li>key의 이동 횟수를 최소화하여 정렬된 배열을 얻을 수 있다.</li>
  <li>Counting idea는 입력된 원소들이 범위를 알고 있는 작은 집합의 값들일 때 생산적으로 작동한다.</li>
</ul>

<h3 id="distribution-counting-sort">Distribution-counting sort</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM DistributionCountingSort(A[0..n-1], l, u)
    //Sorts an array of integers from a limited range by  distribution counting
    //Input: An array A[0..n-1] of integers between l and u (l &lt;= u)
    //Output: Array S[0..n-1] of A's elements sorted in nondecreasing order
        for j &lt;- 0 to u-l do D[j] &lt;- 0
        for i &lt;- 0 to n-1 do D[A[i]-1] &lt;- D[A[i]-l] + 1
        for j &lt;- 1 to u-1 do D[j] &lt;- D[j-1] + D[j]
        for i &lt;- n-1 downto 0 do
            j &lt;- A[i] - l
            S[D[j]-1] &lt;- A[i]
            D[j] &lt;- D[j] - 1
        return S
</code></pre></div></div>

<h2 id="string-matching-problem">String matching problem</h2>
<p>Input-enhancement idea</p>
<ul>
  <li>패턴을 전처리하여 정보를 표에 저장한다.</li>
  <li>주어진 텍스트에서 패턴을 검색할 때 저장된 정보를 이용한다.</li>
  <li>KMP algorithm, Boyer-Moore algorithm, Horspool’s algorithm
(KMP는 앞에서 부터 비교, Boyer-Moore는 뒤에서 부터 비교)</li>
</ul>

<h3 id="horspoola-algorithm">Horspool’a Algorithm</h3>
<ul>
  <li>패턴의 오른쪽에서 왼쪽으로 이동하며 텍스트의 부분문자열과 비교한다.</li>
  <li>텍스트의 부분문자열과 패턴이 일지하지 않을 때 패턴과 일치하는 부분문자열을 빠트리지 않으면서 패턴을 가장 많이 이동시킨다.</li>
  <li>Horspool’s algorithm에선 패턴을 이동시킬 거리를 패턴의 가장 마지막 글자와 대응되는 텍스트의 글자 <code class="language-plaintext highlighter-rouge">c</code>를 보고 결정한다. (가장 처음 비교하는 글자)
    <ul>
      <li>Case 1: <code class="language-plaintext highlighter-rouge">c</code>가 패턴에 없는 글자 일 때
        <p align="center"><img src="/assets/img/[AL]8/hpcase1.png" width="70%" height="70%" /></p>
        <ul>
          <li>패턴의 길이만큼 이동한다.</li>
        </ul>
      </li>
      <li>Case 2: mismatch가 패턴의 마지막 글자에서 발생했고 <code class="language-plaintext highlighter-rouge">c</code>가 패턴에 존재할때
        <p align="center"><img src="/assets/img/[AL]8/hpcase2.png" width="70%" height="70%" /></p>
        <ul>
          <li>패턴의 가장 오른쪽에 있는 <code class="language-plaintext highlighter-rouge">c</code>의 위치가 mismatch가 일어난 위치에 오도록 이동시킨다.</li>
        </ul>
      </li>
      <li>Case 3: mismatch가 중간에서 일어났고 <code class="language-plaintext highlighter-rouge">c</code>가 다른 위치에 없는 경우
        <p align="center"><img src="/assets/img/[AL]8/hpcase3.png" width="70%" height="70%" /></p>
        <ul>
          <li>패턴의 길이만큼 이동한다.</li>
        </ul>
      </li>
      <li>Case 4: mismatch가 중간에서 일어났고 <code class="language-plaintext highlighter-rouge">c</code>가 다른 위치에 존재할 때
        <p align="center"><img src="/assets/img/[AL]8/hpcase4.png" width="70%" height="70%" /></p>
        <ul>
          <li>마지막을 글자를 제외한 가장 오른쪽에 있는 <code class="language-plaintext highlighter-rouge">c</code>가 mismatch가 일어난 위치에 오도록 이동시킨다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="shift-table">Shift table</h4>
<p>Input-enhancement가 불필요한 비교를 반복해서 하지 않도록 한다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">shift table</code>에 이동해야하는 크기를 사전에 저장한다.</li>
  <li><code class="language-plaintext highlighter-rouge">shift table</code>은 패턴에 나오는 글자 뿐만아니라 텍스트에 나올 수 있는 모든 글자들에 대한 정보를 포함한다.</li>
  <li>$t(c)$
    <ul>
      <li>패턴의 길이 $m$ (<code class="language-plaintext highlighter-rouge">c</code>가 패턴의 마지막 글자를 제외한 $m-1$개의 글자에 포함되이 않는 경우)</li>
      <li>패턴의 가장 마지막 글자와 <code class="language-plaintext highlighter-rouge">c</code>와의 거리 (<code class="language-plaintext highlighter-rouge">c</code>가 패턴의 마지막 글자를 제외한 $m-1$개의 글자에 포함되어 있는 경우)</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM shiftTable(P[0..m-1])
    //Fills the shift table used by Horspool's and Boyer-Moore algorithms
    //Input: Parttern P[0..m-1] and an alphabet of possible characters
    //Output: Table[0..size-1] indexed by the alphabet's characters and filled with shift sizes computed by t(c)
    for i &lt;- 0 to size-1 do Table[i] &lt;- m
    for j &lt;- to m-2 do Table[P[j]] &lt;- m-1-j
    return Table
</code></pre></div></div>

<h4 id="horspools-algorithm">Horspool’s Algorithm</h4>
<ul>
  <li>Step 1: 주어진 패턴과 텍스트를 이용하여 <code class="language-plaintext highlighter-rouge">shift table</code>을 만든다.</li>
  <li>Step 2: 텍스트의 시작위치에 패턴을 나열한다.</li>
  <li>Step 3: 패턴과 일치한 부분물자열을 찾거나 텍스트의 마지막 글자에 도달할 때 까지 다음 실행을 반복한다.
    <ul>
      <li>패턴의 마지막 글자부터 패턴과 텍스트를 비교하고 일치하는 부분 문자열을 찾으면 멈춘다.</li>
      <li>mismatch가 일어나면 <code class="language-plaintext highlighter-rouge">shitf table</code>의 $t(c)$ 값 만큼 패턴을 오른쪽으로 이동시킨다.</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algorithm HorspoolMatching(P[0..m-1], T[0..n-1])
    //Implements Horspool's algorithm for string matching
    //Input: Pattern P[0..m-1] and text T[0..n-1]
    //Output: The index of the left end of the first matching substring or -1 if there are no matches
    ShiftTable(P[0..m-1])   //generate Table of shifts
    i &lt;- m-1                //position of the pattern's right end
    while i &lt;= n-1 do
        k &lt;- 0              //number of matched characters
        while k &lt;= m-1 and P[m-1-k] = T[i-k] do
            k &lt;- k+1
        if k=m
            return i-m+1
        else
            i &lt;- i + Table[T[i]]
    return -1
</code></pre></div></div>

<ul>
  <li>worst-case efficiency: $O(mn)$</li>
  <li>for random texts: $\theta(n)$</li>
  <li>Boyer-Moore algorithm 만큼 효율적이다.</li>
  <li>자연어와 유사한 문자열을 다룰 때 간단한 Horspool’s algorithm을 더 선호한다.</li>
</ul>]]></content><author><name>Junhwan</name></author><category term="ComputerScience" /><category term="algorithm" /><category term="CSE214" /><summary type="html"><![CDATA[Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin]]></summary></entry><entry><title type="html">[AL] 7. Transform-and-Conquer</title><link href="http://localhost:4000/computerscience/AL-7-Transform-and-Conquer/" rel="alternate" type="text/html" title="[AL] 7. Transform-and-Conquer" /><published>2022-06-02T00:00:00+09:00</published><updated>2022-06-02T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/%5BAL%5D%207%20Transform-and-Conquer</id><content type="html" xml:base="http://localhost:4000/computerscience/AL-7-Transform-and-Conquer/"><![CDATA[<blockquote>
  <p>Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin</p>
</blockquote>

<h1 id="transform-and-conquer">Transform-and-Conquer</h1>

<h2 id="transform-and-conquer-technique">Transform-and-conquer technique</h2>
<ul>
  <li>두가지 절차
    <ol>
      <li>인스턴스들을 문제를 더 풀기 쉽도록 변형한다</li>
      <li>변형된 입력들로 문제를 해결한다.</li>
    </ol>
  </li>
  <li>주어진 인스턴스의 세 가지 주요 변형:
    <ol>
      <li>Instance Simplication: 동일한 문제의 더 단순하고 편리한 인스턴스로 전환</li>
      <li>Representation change: 동일한 인스턴스의 다른 표현으로 변경</li>
      <li>Problem reduction: 알고리즘을 이미 사용할 수 있는 다른 문제로 이동</li>
    </ol>
  </li>
</ul>

<h2 id="instance-simplication">Instance Simplication</h2>
<p>동일한 문제의 다른 단순하고 쉬운 인스턴스로 변환하여 문제 해결</p>

<h3 id="presorting">Presorting</h3>
<p>리스트와 관련된 많은 문제는 리스트를 정렬되었을 때 쉽게 풀 수 있다.</p>
<ul>
  <li>searching</li>
  <li>selection problem</li>
  <li>element uniqueness
알고리즘의 시간 효율은 사용하는 정렬 알고리즘의 효율성에 따라 달라질 수 있다.</li>
</ul>

<h4 id="checking-element-uniqueness">Checking Element Uniqueness</h4>
<ul>
  <li>Brute Force algorithm
    <ul>
      <li>모든 원소 쌍들을 비교한다.</li>
      <li>The worst-case efficiency: $\Theta(n^2)$</li>
    </ul>
  </li>
  <li>Presorting-based algorithm
    <ul>
      <li>Stage 1 : 효울적인 정렬 알고리즘으로 원소들을 정렬한다.</li>
      <li>Stage 2 : 인접한 두 원소가 같은 값인지 확인한다.</li>
      <li>Efficiency : $T(n)=T_{sort}(n)+T_{scan}(n) \in \theta(n\log n)+\theta(n) = \theta(n \log n)$</li>
      <li>
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM PresortElementUniqueness(A[0..n-1])
    //Solved the arry uniqueness problem by sorting the array first
    //Input: An Arrays A[0..n-1] of oderable elements
    //Output: Returns "true" if A has no equal elements, "false" otherwise
    sort the array A
        
    for i &lt;- 0 to n-2 do
        if A[i] = A[i+1] return false
    return true
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="computing-a-mode">Computing a mode</h4>
<p>주어진 숫자 리스트에서 최빈값을 찾는 문제</p>
<ul>
  <li>Brute Force algorithm
    <ul>
      <li>각 원소들의 빈도를 나타내는 리스트를 만들어 비교한다.</li>
      <li>The worst-case efficiency: $\Theta(n^2)$</li>
    </ul>
  </li>
  <li>Presorting-based algorithm
    <ul>
      <li>Stage 1 : 효울적인 정렬 알고리즘으로 원소들을 정렬한다. (원소들을 정렬하면 같은 원소들은 서로 인접하게된다.)</li>
      <li>Stage 2 : 인접한 같은 원소들의 갯수를 센다.</li>
      <li>
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM PresortMode(A[0..n-1])
    //Computes the mode of an array by sorting it  first
    //Input: An Arrays A[0..n-1] of oderable elements
    //Output: The array's mode 
    sort the array A
    i &lt;- 0
    modefrequency &lt;- 0
    while i&lt;= n-1 do
      runlength &lt;- 1; runvalue &lt;- A[i]
      while i + runlength &lt;= n-1 and A[i + runlength] = runvalue
        runlength &lt;- runlength + 1
      if runlength &gt; mmodefrequency
        modefrequency &lt;- length; modevalue &lt;- runvalue
      i &lt;- i + runlength
    return modevalue
</code></pre></div>        </div>
      </li>
      <li>알고리즘이 실행되는 시간은 정렬이 실행되는 시간에 의해 결정된다.</li>
    </ul>
  </li>
</ul>

<h4 id="searching-problem">Searching problem</h4>
<p>주어진 <code class="language-plaintext highlighter-rouge">K</code>를 `A[0..n-1]에서 찾는 문제</p>
<ul>
  <li>Brute Force algorithm
    <ul>
      <li>순차탐색</li>
      <li>Efficiency: $O(n)$</li>
    </ul>
  </li>
  <li>Presorting-based algorithm
    <ul>
      <li>Stage 1: 효울적인 정렬 알고리즘으로 원소들을 정렬한다.</li>
      <li>Stage 2: binary search를 사용한다.</li>
      <li>$T(n) = T_{sort}(n) + T_{search}(n) \in \Theta(n \log n) + \Theta(\log n)= \Theta(n \log n)$</li>
      <li>순차탐색보다 오래걸리지만 탑색을 한 번 이상 해야될 경우 유용하다.</li>
    </ul>
  </li>
</ul>

<p>점들의 집합을 다루는 많은 기하학적 알고리즘은 한 가지 방법 또는 다른 방법으로 사전 정렬을 사용한다.
방향 비순환 그래프의 일부 문제는 해당 이중 그래프를 위상적으로 정렬한 후 더 쉽게 해결할 수 있다.
대부분의 그리디 알고리즘은 입력의 사전 정렬을 그들의 작업의 본질적인 부분으로 요구한다.</p>

<h2 id="searching-algorithm의-분류">Searching algorithm의 분류</h2>
<ul>
  <li>List searching
    <ul>
      <li>sequential search</li>
      <li>binary search</li>
      <li>interpolation search</li>
    </ul>
  </li>
  <li>Tree searhcing
    <ul>
      <li>binary search tree</li>
      <li>binary balanced trees: AVL trees, red-black trees</li>
      <li>multiway balanced trees: 2-3 trees, 2-3-4 trees, B trees</li>
    </ul>
  </li>
  <li>Hashing
    <ul>
      <li>open hashing (separate chaining)</li>
      <li>closed hashing (open addressing)</li>
    </ul>
  </li>
</ul>

<h3 id="binary-search-tree">Binary Search Tree</h3>
<p>노드당 하나의 요소인 정렬 가능한 항목 집합의 요소를 포함하는 이진 트리.
왼쪽 하위 트리의 모든 요소가 하위 트리의 루트 요소보다 작고 오른쪽 하위 트리의 모든 요소가 하위 트리보다 큽니다.
집합에서 이진 검색 트리로의 변환은 <code class="language-plaintext highlighter-rouge">reqresentation-change technique</code>의 한 예이다.</p>
<ul>
  <li>Operations
    <ul>
      <li>Searching</li>
      <li>Insertion</li>
      <li>Deletion</li>
    </ul>
  </li>
  <li>worst case efficiency : $\Theta(n)$</li>
  <li>average case efiiciency : $\Theta(\log n)$</li>
  <li>중위순회로 정렬할 수 있다.</li>
</ul>

<h3 id="balanced-search-trees">Balanced Search Trees</h3>
<p>한 쪽으로 치우치는 worst-case를 피하기 위해 만들어진 Tree</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">unbalanced binary search tree</code>를 <code class="language-plaintext highlighter-rouge">balanced binary search tree</code>로 바꾸는 방법 (<code class="language-plaintext highlighter-rouge">instance-simplication</code>)
    <ul>
      <li>self-balancing</li>
      <li>AVL trees</li>
      <li>red-black trees</li>
    </ul>
  </li>
  <li>각 노드에 너 두 개 이상의 노드를 포함하도록 하는 방법 (<code class="language-plaintext highlighter-rouge">representation-change</code>)
    <ul>
      <li>2-3 trees</li>
      <li>2-3-4 trees</li>
      <li>B-trees</li>
    </ul>
  </li>
</ul>

<h4 id="avl-trees">AVL trees</h4>
<p>모든 노드의 <code class="language-plaintext highlighter-rouge">balance factor</code>가 $0$, $-1$, $+1$인 트리</p>

<ul>
  <li>Rotation : 새로운 노드가 삽입되었을 때 AVL tree가 unbalanced해진다면 <code class="language-plaintext highlighter-rouge">rotation</code>를 통해 바꿔준다.
    <ul>
      <li>single right rotation (R-rotation)</li>
      <li>single left rotation (L-rotation)</li>
      <li>double left-right rotation (LR-rotation)</li>
      <li>double right-left rotation (RL-rotation)</li>
    </ul>
  </li>
  <li>Efficiency : $\Theta(\log n)$</li>
  <li>단점
    <ul>
      <li>rotation이 자주 일어난다.</li>
      <li>각 노드의 <code class="language-plaintext highlighter-rouge">balance factor</code>를 관리해야한다.</li>
    </ul>
  </li>
</ul>

<h4 id="multiway-search-trees">Multiway Search Trees</h4>
<p>같은 노드에 한개 이상의 <code class="language-plaintext highlighter-rouge">key</code>를 갖는 것을 허용하는 트리
$n-1$개의 정렬된 <code class="language-plaintext highlighter-rouge">key</code>를 가진 노드를 <code class="language-plaintext highlighter-rouge">n-node</code>라고 한다.</p>

<h5 id="2-3-trees">2-3 trees</h5>
<ul>
  <li><code class="language-plaintext highlighter-rouge">2-node</code>와 <code class="language-plaintext highlighter-rouge">3-node</code>만을 갖는 트리</li>
  <li>모든 <code class="language-plaintext highlighter-rouge">leaf node</code>가 같은 <code class="language-plaintext highlighter-rouge">level</code>에 존재한다.</li>
  <li><code class="language-plaintext highlighter-rouge">3-node</code>인 <code class="language-plaintext highlighter-rouge">leaf node</code>에 삽입이 일어난다면 가운데 <code class="language-plaintext highlighter-rouge">key</code>를 기준으로 두개로 나눈다.</li>
  <li>$\log_{3}(n+1)-1 \leq h \leq log_{2}(n+1)-1$</li>
  <li>Efficiency : $\Theta(\log n)$</li>
</ul>

<h4 id="heap">Heap</h4>
<p>Heap은 가장 효율적으로 우선순위 큐를 구현하는 방법이다.
다음 두가지 조건을 만족하는 binary tree이다.</p>
<ol>
  <li>shape property
    <ul>
      <li>`essentially complete (simply complete)</li>
      <li>마지막 <code class="language-plaintext highlighter-rouge">level</code>을 제외한 모든 <code class="language-plaintext highlighter-rouge">level</code>에 노드가 모두 차있고 마지막 <code class="language-plaintext highlighter-rouge">level</code>만 오른쪽에서 부터 비어있다.</li>
    </ul>
  </li>
  <li>parental dominance
    <ul>
      <li>모든 노드의 <code class="language-plaintext highlighter-rouge">key</code>값은 자식 노드의 키 값보다 크거나 같아야한다.</li>
    </ul>
  </li>
</ol>

<ul>
  <li>Heap properties
    <ul>
      <li>형제노드들끼리의 순서는 존재하지 않는다.</li>
      <li>root 노드의 <code class="language-plaintext highlighter-rouge">key</code>값은 가장 큰 <code class="language-plaintext highlighter-rouge">key</code>값이다.</li>
      <li>배열로 구현이 가능하다.</li>
      <li>모든 노드를 root로 하는 <code class="language-plaintext highlighter-rouge">subtree</code> 또한 heap 이다.</li>
    </ul>
  </li>
</ul>

<h5 id="heap-sort">Heap Sort</h5>
<ul>
  <li>Stage 1: 주어진 배열으로 heap을 만든다.
    <ul>
      <li>worst-case : $O(n)$</li>
    </ul>
  </li>
  <li>Stage 2: heap에서 n-1번 삭제하여 순서대로 나열한다.
    <ul>
      <li>worst-case : $O(n \log n)$</li>
    </ul>
  </li>
  <li>in-place</li>
  <li>heapsort는 quicksort보다 느리고 mergesort와 비슷한 속도를 보인다.</li>
</ul>

<h2 id="horners-rule">Horner’s Rule</h2>
<p><code class="language-plaintext highlighter-rouge">representation-change</code> technique의 예로 다항식을 계산하는 알고리즘이다.
\(p(x) = (\cdots(a_nx+a_{n-1})x+\cdots )x+a_0\)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM Horner(P[0..n], x)
    //Evaluates a polynomial at a given point by Horner's rule
    //Input: An array P[0..n] of coefficients of a polynomial of degree n, sorted from the lowest to the highest and a number x
    //Output: The value of the polynomial at x
    p &lt;- P[n]
    for i &lt;- n-1 downto 0 do
        p &lt;- x*p + P[i]
    return p
</code></pre></div></div>

<p>곱셈과 덧셈의 횟수는 모두 $n$이다.</p>

<h2 id="problem-reduction">Problem Reduction</h2>
<ul>
  <li>문제를 이미 해결방법을 알고 있는 다른 문제로 바꾸어 해결한다.</li>
  <li>문제를 변형하는 시간과 변형된 문제를 해결하는 시간이 기존의 문제를 해결하는 시간보다 효율적이어야한다.</li>
  <li>Examples
    <ul>
      <li>$lcm(m,n)$을 $gcm(m,n)$을 구해 해결한다.</li>
      <li>그래프에서 길이가 $n$인 경로의 갯수를 인접행렬의 $n$제곱을 이용해 구할 수 있다.</li>
      <li>최대값 문제와 최솟값 문제를 서로 변형한다.</li>
    </ul>
  </li>
</ul>

<h3 id="computing-the-least-common-multiple">Computing the Least Common Multiple</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">GCD</code>를 구하는 매우 효율적인 알고리즘인 유클리드 알고리즘을 이용하여 구한다.
\(lcm(m,n) = {m\cdot n\over{gcd(m,n)}}\)</li>
</ul>

<h3 id="countingn-paths-in-a-graph">Countingn Paths in a Graph</h3>
<ul>
  <li>두개의 정점 사이의 경로의 갯수를 구하는 문제</li>
  <li>길이가 $k$인 <code class="language-plaintext highlighter-rouge">i</code>번째 정점에서 <code class="language-plaintext highlighter-rouge">j</code>번째 정점으로 가는 경로의 갯수는 $A$가 인접 행렬일 때 $A^k$의 <code class="language-plaintext highlighter-rouge">(i,j)</code>번째 요소와 같다.</li>
</ul>

<h3 id="reduction-of-optimization-problems">Reduction of Optimization problems</h3>
<ul>
  <li>maximization problem : 어떤 함수의 최댓값을 찾는 문제</li>
  <li>minimization problem : 어떤 함수의 최솟값을 찾는 문제</li>
  <li>$\min f(x)=-\max [-f(x)]$</li>
</ul>

<h4 id="linear-programming">Linear Programming</h4>
<ul>
  <li>어떤 선형 방정식과 선형 부등식을 만족하는 여러 변수의 선형 함수를 최적화하는 문제</li>
  <li>많은 optimal decision making 문제는 linear programming problem으로 ruduced 될 수 있다.</li>
</ul>

<h3 id="reduction-to-graph-problems">Reduction to Graph Problems</h3>
<ul>
  <li>많은 문제들이 그래프 문제로 reduction 될 수 있다.</li>
  <li>정점은 가능한 <code class="language-plaintext highlighter-rouge">states</code>를 나타낸다.</li>
  <li>간선은 각 정점들 사이의 <code class="language-plaintext highlighter-rouge">transitions</code>를 나타낸다.</li>
  <li><code class="language-plaintext highlighter-rouge">initial state</code>를 <code class="language-plaintext highlighter-rouge">goal state</code>로 찾아가는 문제이다.</li>
  <li>이 그래프는 <code class="language-plaintext highlighter-rouge">state-space graph</code>라고 부른다.</li>
</ul>]]></content><author><name>Junhwan</name></author><category term="ComputerScience" /><category term="algorithm" /><category term="CSE214" /><summary type="html"><![CDATA[Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin]]></summary></entry><entry><title type="html">[AL] 6. Divide-and-Conquer</title><link href="http://localhost:4000/computerscience/AL-6-Divide-and-Conquer/" rel="alternate" type="text/html" title="[AL] 6. Divide-and-Conquer" /><published>2022-05-02T00:00:00+09:00</published><updated>2022-05-02T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/%5BAL%5D%206%20Divide-and-Conquer</id><content type="html" xml:base="http://localhost:4000/computerscience/AL-6-Divide-and-Conquer/"><![CDATA[<blockquote>
  <p>Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin</p>
</blockquote>

<h1 id="divide-and-conquer">Divide-and-Conquer</h1>

<h2 id="divide-and-conquer-technique">Divide-and-conquer technique</h2>
<ul>
  <li>가장 잘 알려진 알고리즘 설계 기법이다.</li>
  <li>문제는 같은 유형의 이상적으로 크기가 같은 여러 하위 문제로 나뉜다.</li>
  <li>하위문제는 일반적으로 재귀적으로 해결되고 하위 문제에 대한 솔루션을 결합하여 원래 문에에 대한 솔루션을 구한다.</li>
  <li>Divide-and-conquer technique은 각각의 하위문제를 자체 프로세서에 의해 동시에 해결할 수 있는 병렬 계산에 이상적으로 적합하다.</li>
</ul>

<p align="center"><img src="/assets/img/%5BAL%5D6/dividenconquer.png" width="70%" height="70%" /></p>

<h2 id="general-divide-and-conquer-recurrence">General divide-and-conquer recurrence</h2>
<p>사이즈가 $n$인 인스턴스를 사이즈가 $n/b$인 인스턴스로 나누고 그것을 $a$번 풀어야할 때, $a\ge1$, $b&gt;1$. 
\(T(n)=aT(n/b)+f(n)\)
$f(n)$은 인스턴스를 나누고 합치는데 걸리는 시간에 대한 함수이다.</p>

<h3 id="master-theorem">Master Theorem</h3>

<p>If $f(n)\in\Theta(n^d)$ where $d\ge 0$ in recurrence, then
\(T(n)\in 
\begin{cases} 
\Theta(n^d) \qquad \quad \ if\ a&lt;b^d\\ 
\Theta(n^d\log n) \quad if\ a&lt;b^d\\ 
\Theta(n^{\log_ba})\quad \ \ \ if\ a&lt;b^d
\end{cases}\)</p>

<h2 id="mergesort">Mergesort</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM Mergesort(A[0..n-1])
    //Input: An Array A[0..n-1] of orderable elements
    //Output: Array A[0..n-1] sorted in nondecreasing order
    if n &gt; 1
        copy A[0..⌊n/2⌋-1] to B[0..⌊n/2⌋-1]
        copy A[⌊n/2⌋..n-1] to C[0..⌊n/2⌋-1]
        Mergesort(B[0..⌊n/2⌋-1])
        Mergesort(C[0..⌊n/2⌋-1])
        Merge(B, C, A)

</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM Merge(B[0..p-1], C[0..q-1], A[0..p+q-1])
    //Input: Arrays B[0..p-1] and C[0..q-1] both sorted
    //Output: Sorted array A[0..p+q-1] of the elements of B and C
    i &lt;- 0; j &lt;- 0; k &lt;- 0;
    while i &lt; p and j &lt; q do
        if B[i] &lt;= C[j]
            A[k] &lt;- B[i]; i &lt;- i+1
        else 
            A[k] &lt;- C[j]; j &lt;- j+1
        k &lt;- k+1
    if i = p
        copy C[j..q-1] to A[k..p+q-1]
    else
        copy B[i..p-1] to A[k..p+q-1]    
</code></pre></div></div>

<p align="center"><img src="/assets/img/%5BAL%5D6/mergesort.png" width="70%" height="70%" /></p>

<ul>
  <li>The number of key comparison
    <ul>
      <li>$C(n) = 2C(n/2)+C_{merge}(n)$ for $n&gt;1$, $C(1)=0$</li>
      <li>$C_{merge}(n) = n-1$</li>
      <li>$C_{worst}(n) = 2C_{worst}(n/2)+n-1$ for $n&gt;1$, $C_{worst}(1)=0$</li>
      <li>C_{worst}(n)\in\Theta(n\log n)$</li>
    </ul>
  </li>
  <li>Stable</li>
  <li>Space requirement : $\Theta(n)$ (not in-place)</li>
</ul>

<h2 id="quicksort">Quicksort</h2>
<p align="center"><img src="/assets/img/%5BAL%5D6/quicksort.png" width="70%" height="70%" /></p>
<ul>
  <li>Mergesort가 요소들의 위치에 따라 나눈거라면 Quicksort는 값에 따라 나눈다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM Quicksort(A[l..r])
    //Input: Subarray of array A[0..n-1], defined by its left and right indices l and r
    //Output: Subarray A[l..r] sorted in nondecreasing order
    if l &lt; r
        s &lt;- Partition(A[l..r]) // s is a split position
        Quicksort(A[l..s-1])
        Quicksort(A[s+1..r])
</code></pre></div></div>

<h3 id="partitioning-algorithm">Partitioning Algorithm</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM HoarePartition(A[l..r])
    //Input: Subarray of array A[0..n-1], defined by its left and right indices l and r (l &lt; r)
    //Output: Partition of A[l..r], with the split position returned as this function's value 
    p &lt;- A[l]
    i &lt;- l; j &lt;-  r+1
    repeat
        repeat i &lt;- i+1 until A[i] &gt;= p
        repeat j &lt;- j-1 until A[j] &lt;= q
        swap(A[i], A[j])
    until i &gt;= j
    swap(A[i], A[j]) //undo last swap when i &gt;= j
    swap(A[l], A[j])
    return j
</code></pre></div></div>
<p align="center"><img src="/assets/img/%5BAL%5D6/pa1.png" width="70%" height="70%" /></p>
<p align="center"><img src="/assets/img/%5BAL%5D6/pa2.png" width="70%" height="70%" /></p>
<p align="center"><img src="/assets/img/%5BAL%5D6/pa3.png" width="70%" height="70%" /></p>

<h3 id="analysis-of-quicksort">Analysis of Quicksort</h3>
<ul>
  <li>Best case: 중간에서 split — $\Theta(n\log n)$</li>
  <li>Worst case: 이미 정렬된 배열 — $\Theta(n^2)$</li>
  <li>Average case: random 배열 —$\Theta(n\log n)$
    <ul>
      <li>보통 Mergesort보다 빠르다</li>
    </ul>
  </li>
  <li>Improvements:
    <ul>
      <li>pivot을 선택할 때 세 개의 값중 중간값을 선택</li>
      <li>매우 작은 subarray에서 insertion sort 사용</li>
    </ul>
  </li>
  <li>Not Stable</li>
</ul>

<h2 id="binay-tree">Binay Tree</h2>
<p>Binary trees와 관련된 많은 문제가 divede-and-conquer technique로 해결된다.
<img src="/assets/img/%5BAL%5D6/BT.png" width="70%" height="70%" /></p>

<h3 id="height">Height</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM HEIGHT(T)
    //Input: A binary tree T
    //Output: The height of T
    if T = NULL return -1
    else return max{Height(T_left), Height(T_right)}+1
</code></pre></div></div>
<h3 id="traversals">Traversals</h3>
<ul>
  <li>preorder traversal</li>
  <li>inorder traversal</li>
  <li>postorder traversal</li>
</ul>

<h3 id="multiplication-of-large-integers">Multiplication of Large Integers</h3>

<p>두 자리수 정수$a$, $b$를 $a=a_1a_0$,  $b=b_1b_0$로 나누어 계산한다.</p>

\[c = a*b = c_210^2+c_110^1+c_0\]

<p>$c_2=a_1*b_1$ 첫째 자리수의 곱</p>

<p>$c_0=a_0*b_0$ 둘재 자리 수의 곱</p>

<p>$c_1=(a_1+a_0)*(b_1+b_0)-(c_2+c_0)$ 각 자리수의 합을 곱한 값에 $c_2$, $c_0$를 뺀 값</p>

<p>$n$-자리수의 경우</p>

\[c = a*b = c_210^n+c_110^{n/2}+c_0\]

<p>$c_2=a_1*b_1$ 앞쪽 반의 자리수의 곱</p>

<p>$c_0=a_0*b_0$ 뒷쪽 반의 자리수의 곱</p>

<p>$c_1=(a_1+a_0)*(b_1+b_0)-(c_2+c_0)$ 각 자리수의 합을 곱한 값에 $c_2$, $c_0$를 뺀 값</p>

<ul>
  <li>곱 횟수 : $M(n)=3M(n/2)$ for $n&gt;1$, $M(1)=1$.
    <ul>
      <li>$M(n) = 3^{\log_2n}$</li>
    </ul>
  </li>
</ul>

<h3 id="closest-pair-problem">Closest-Pair Problem</h3>
<p><img src="/assets/img/%5BAL%5D6/cp1.png" width="30%" height="30%" />
<img src="/assets/img/%5BAL%5D6/cp2.png" width="60%" height="60%" /></p>

<ul>
  <li>Recurrence for the running time of the algorithm
    <ul>
      <li>$T(n) = 2T(n/2) + f(n) $, where $f(n)\in\Theta(n)$</li>
      <li>Applying the Master Theorem (with $a=2$, $b=2$, and $d=1$),  $T(n)\in\Theta(n\log n)$</li>
    </ul>
  </li>
</ul>

<h3 id="convex-hull">Convex-Hull</h3>
<ul>
  <li>Quickhull
    <ul>
      <li>$n$개의 점들 ($p_1(x_1, y_1), \cdots, p_n(x_n,y_n)$이 집합 $S$에 속해있다.</li>
      <li>$n$개의 점들을 $x$좌표를 기준으로 정렬한 뒤 양 끝점 $p_1$, $p_n$을 지나는 직선을 중심으로 위쪽을 $S_1$, 아래쪽을 $S_2$로 $S$를 두개의 평면으로 나눈다.</li>
    </ul>
  </li>
</ul>
<p align="center"><img src="/assets/img/%5BAL%5D6/ch1.png" width="60%" height="60%" /></p>

<h4 id="quickhull">Quickhull</h4>
<ul>
  <li>$S_1$이 비어있을 경우 두 점 $p_1$, $p_n$을 연결한 선분을 추가한다.</li>
  <li>$S_1$이 비어있지 않을 경우 집합 $S_1$의 점중 직선 $\overrightarrow{p_1p_n}$과의 거리가 가장 먼 점 $p_max$을 찾는다.</li>
  <li>$\overrightarrow{p_1p_{max}}$의 왼쪽에 있는 점들의 집합을 $S_{1,1}$, $\overrightarrow{p_{max}p_n}$의 왼쪽에 있는 점들의 집합을 $S_{1,2}$라고 하고 이 집합들에 대해 위의 과정을 반복한다.</li>
</ul>

<p align="center"><img src="/assets/img/%5BAL%5D6/qh.png" width="60%" height="60%" /></p>

<ul>
  <li>worst-case : $\Theta(n^2)$</li>
  <li>average-case : lnear</li>
</ul>]]></content><author><name>Junhwan</name></author><category term="ComputerScience" /><category term="algorithm" /><category term="CSE214" /><summary type="html"><![CDATA[Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin]]></summary></entry><entry><title type="html">[AL] 5. Decrease-and-Conquer</title><link href="http://localhost:4000/computerscience/AL-5-Decrease-and-Conquer/" rel="alternate" type="text/html" title="[AL] 5. Decrease-and-Conquer" /><published>2022-05-02T00:00:00+09:00</published><updated>2022-05-02T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/%5BAL%5D%205%20Decrease-and-Conquer</id><content type="html" xml:base="http://localhost:4000/computerscience/AL-5-Decrease-and-Conquer/"><![CDATA[<blockquote>
  <p>Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin</p>
</blockquote>

<h1 id="decrease-and-conquer">Decrease-and-Conquer</h1>

<h2 id="decrease-and-conquer-technique">Decrease-and-conquer technique</h2>
<p>문제에서 주어진 인스턴스에 대한 솔루션과 더 작은 인스턴스에 대한 솔루션 사이의 관계를 기반으로 문제를 푼다.</p>
<ul>
  <li>하향식(Top down) → 재귀적으로 구현(최종 구현은 비재귀적일 수 있음)</li>
  <li>상향식(Bottom up) → 반복적 구현
    <ul>
      <li>문제의 가장 작은 사례에 대한 해결책부터 시작하여 점진적dmfh 접근</li>
    </ul>
  </li>
</ul>

<h2 id="decrease-by-a-constant">Decrease by a constant</h2>
<p>알고리즘이 반복될 때 마다 인스턴스의 크기를 같은 상수만큼 줄인다. (보통 $1$)
<img src="/assets/img/%5BAL%5D5/decreasebyconstant.png" alt="decreasebyconstant" width="50%" height="50%" /></p>

<h3 id="the-exponentiation-problem">The exponentiation problem</h3>
<p>cmputing $a^n$</p>
<ul>
  <li>Top down
    <ul>
      <li>
\[f(n)=\begin{cases}
f(n-1) \cdot a \quad if\ n&gt;0 \\
1 \qquad\quad\quad\quad\ \ if\ n=0
        
\end{cases}\]
      </li>
    </ul>
  </li>
  <li>Botoom up
    <ul>
      <li>1에서부터 $a$를 $n$번 곱한다.</li>
    </ul>
  </li>
</ul>

<h3 id="insertion-sort">Insertion sort</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM InsertionSort(A[0..n-1])
    //Input: An array A[0..n-1] of n orderalbe elements
    //Output: Array A[0..n-1] sorted in nondecreasing order
    for i &lt;- 1 to n-1 do
        v &lt;- A[i]
        j &lt;- i-1
        while j&gt;=0 and A[j]&gt;v do
            A[j+1] &lt;- A[j]
            j &lt;- j-1
        A[j+1] &lt;- v
</code></pre></div></div>

<p>\(A[0]\le\cdots\le A[j]&lt;A[j+1]\le \cdots \le A[i-1] \ \vert\ A[i]\  \cdots \ A[n-1]\)</p>
<ul>
  <li>basic operation : key comparison <code class="language-plaintext highlighter-rouge">A[j] &gt; v</code></li>
  <li>the worst-case
    <ul>
      <li>
\[C_{worst}(n)=\sum^{n-1}_{i=1}\sum^{i-1}_{j=0}1=\sum^{n-1}_{i=1}i={n(n-1)\over2}\in\Theta(n^2)\]
      </li>
    </ul>
  </li>
  <li>the best-case
    <ul>
      <li>
\[C_{best}(n)=\sum^{n-1}_{i=1}1=n-1\in\Theta(n)\]
      </li>
    </ul>
  </li>
  <li>the average-case
    <ul>
      <li>$$C_{avg}(n)\approx{n^2\over4}\in\Theta(n^2)</li>
    </ul>
  </li>
</ul>

<h3 id="topological-sorting">Topological sorting</h3>
<p><code class="language-plaintext highlighter-rouge">Dag</code> : directed acyclic graph
<code class="language-plaintext highlighter-rouge">Topological sorting</code> : dag의 정점들에 대해 모든 starting 정점이 ending 정점보다 앞에 위치하는 선형적인 순서에 따라 정렬하며 dag에서만 가능하다</p>

<ul>
  <li>Source-removal algorithm : 들어오는 간선이 없는 정점들과 그 정점에서 나가는 간선들을 지워가면서 정렬한다</li>
</ul>

<h2 id="decrease-by-a-constant-factor">Decrease by a constant factor</h2>
<p>알고리즘이 반복될 때 마다 인스턴스의 크기를 같은 상수 factor 만큼 줄인다. (보통 $1/2$)</p>

<p><img src="/assets/img/%5BAL%5D5/decreasebyconstantfactor.png" alt="decreasebyconstantfactor" width="48%" height="48%" /></p>

<h3 id="the-exponentiation-problem-1">The exponentiation problem</h3>
<p>\(a^n= \begin{cases}
    (a^{n/2})^2 \qquad \quad\ \  if\ n\ is\ even\ and\ positive, \\
    (a^{(n-1)/2})^2\cdot a \quad if\ n\ is\ odd\,\\
    1 \qquad\qquad \quad \ \ \ \ if\ n=0
\end{cases}\)</p>

<h3 id="binary-search">Binary search</h3>

<p align="center"><img src="/assets/img/%5BAL%5D5/bs1.png" width="50%" height="50%" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM BinarySearch(A[0..n-1], K)
    //Input: An array A[0..n-1] sorted in ascending order and a search key K
    //Output: An index of the array's element that is equal to k or -1 if there is no such element
    l &lt;- 0; r &lt;- n-1
    while l &lt;= r do
        m &lt;- ⌊(l+r)/2⌋
        if K = A[m] return m
        else if K &lt; A[M] r &lt;- m-1
        else l &lt;- m+1
    return -1 
</code></pre></div></div>

<p>For $K=70$</p>
<p align="center"><img src="/assets/img/%5BAL%5D5/bs2.png" width="60%" height="60%" /></p>

<h3 id="fake-coin-problem">Fake-Coin Problem</h3>

<h3 id="russian-peasant-multiplication">Russian Peasant Multiplication</h3>
<p>두 양수의 곱을 구하는 문제</p>

<p><img src="/assets/img/%5BAL%5D5/RPM.png" width="50%" height="50%" /></p>
<ul>
  <li>$n\cdot m =\begin{cases} {n\over2}\cdot 2m \ {n-1\over2}\cdot 2m + m \end{cases}$</li>
  <li>$1\cdot m = m$ to stop</li>
</ul>

<h2 id="variable-size-decrease">Variable-size decrease</h2>

<h3 id="euclids-algorithm">Euclid’s algorithm</h3>
<p>\(gcd(n,\ m) = gcd(n,\ m\ mod \ n)\)</p>

<h3 id="selection-problem">Selection problem</h3>
<p>$n$개의 원소 중 $k$번째로 작은 수를 찾는 문제</p>
<ul>
  <li>정렬 기반 알고리즘
    <ul>
      <li>Efficiency : $O(n\log n)$</li>
    </ul>
  </li>
  <li>partitioning
    <ul>
      <li><img src="/assets/img/%5BAL%5D5/partitioning.png" width="70%" height="70%" /></li>
    </ul>
  </li>
</ul>

<h4 id="lomuto-partitioning">Lomuto partitioning</h4>
<p><img src="/assets/img/%5BAL%5D5/lomuto.png" width="70%" height="70%" /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM LomutoPartition(A[l..r])
    //Input: A subarray A[1..r] of array A[0..n-1], defined by its left and right indices l and r (l&lt;=r)
    //Output: Partition of A[l..r] and the new position of the pivot
    p &lt;- A[l]
    s &lt;- l
    for i &lt;- l to r do
        if A[i] &lt; p
            s &lt;- s+1; swap(A[s], A[i])
    swap(A[l], A[s])
    return s
</code></pre></div></div>

<ul>
  <li>$s=k-1$ 이라면 문제 해결</li>
  <li>$s&gt;k-1$ 왼쪽에서 $k$번째로 작은 원소 다시 탐색</li>
  <li>$s&lt;k-1$ 오른쪽에서 $(k-s)$번째로 작은 원소 다시 탐색</li>
</ul>

<h4 id="quickselect-algorithm">Quickselect algorithm</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM Quickselect(A[l..r], k)
    //Input: Subarray A[1..r] of array A[0..n-1] of orderable elements and iteger k(1&lt;=k&lt;=r-l+1) 
    //Output: The value of the kth smallest element in A[l..r]
    s &lt;- LomutoPartition(A[l..r]) //or another partition algorithm
    if s=l+k-1 return A[s]
    else if s&gt;l+k-1 Quickselect(A[l..s-1], k)
    else Quickselect(A[s+1..r], l+k-1-s)
</code></pre></div></div>
<ul>
  <li>$C_{best}(n) = n-1 \in \Theta(n).$</li>
  <li>$C_{worst}(n) = (n-1) + (n-2) + \ \cdots\ + 1 = (n-1)n/2 \in \Theta(n^2)$</li>
  <li>$C_{avg}(n) \rightarrow linear$</li>
</ul>

<h3 id="interpolation-search">Interpolation search</h3>
<ul>
  <li>binary search : search key를 항상 정렬된 배열의 중앙값과 비교</li>
  <li>Interpolation search : search key의 값을 고려하여 비교할 값을 정함
    <p align="center"><img src="/assets/img/%5BAL%5D5/interpolation.png" width="70%" height="70%" /></p>
  </li>
</ul>

\[x=l+\lfloor{(v-A[l])(r-l)\over A[r]-A[l]}\rfloor\]

<ul>
  <li>Efficiency
    <ul>
      <li>Basic operation: key comparison</li>
      <li>average case: $C(n)&lt;\log_2\log_2 n +1$</li>
      <li>worst case: $C(n)=n$</li>
    </ul>
  </li>
</ul>

<h3 id="binary-search-tree">Binary Search Tree</h3>
<ul>
  <li>Efficiency
    <ul>
      <li>$C_{worst}(n) = \Theta(n)$</li>
      <li>$C_{avg}(n) = \Theta(\log n)$</li>
    </ul>
  </li>
</ul>

<h2 id="generating-combinatorial-objects">Generating Combinatorial Objects</h2>
<p>Minimal-change requirement</p>
<ul>
  <li>Advantage of this order in TSP</li>
</ul>

<h4 id="johnson-trotter-algorithm">Johnson-Trotter algorithm</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM JohnsonTrotter(n)
    //Input: A positive integer n
    //Output: A list of all permutations of {1,...,n}
    initialize the first permutation with 1(&lt;-)2(&lt;-)...n(&lt;-)
    while the last permutation has a mobile element do
        find its largest mobile element k
        swap k with the adjacent element k's arrow points to
        reverse the direction of all the elements that are larger than k
        add the new permutation to the lis
</code></pre></div></div>
<ul>
  <li>An application of Johnson-Trotter algorithm $(n=3)$
    <p align="center"><img src="/assets/img/%5BAL%5D5/J-T.png" width="70%" height="70%" /></p>
  </li>
  <li>가장 효율적인 generating permutations 알고리즘 중 하나이다.</li>
  <li>Time efficiency: Θ(𝑛!)</li>
</ul>

<h2 id="generating-subsets">Generating Subsets</h2>
<p>Minimal change algorithm</p>

<h3 id="binary-reflected-gray-code-brgc">Binary Reflected Gray Code (BRGC)</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM BRGC(n)
    //Input: A positive integer n
    //Output: A list of all bit strings of length n composing the Gray code
    if n=1 make list L containing bit string 0 and 1 in this order
    else generate list L1 of bit strings of size n-1 by calling BRGC(n-1)
        copy list L1 to list L2 in reversed order
        add 0 in front of each bit string in list L1
        add 1 in front of each bit string in list L2
        append L2 to L1 to get list L
    return L
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">L</code>의 첫번째 원소와 마지막 원소도 1 비트 차이나기 때문에 <code class="language-plaintext highlighter-rouge">cyclic</code>이라고 한다.</li>
</ul>]]></content><author><name>Junhwan</name></author><category term="ComputerScience" /><category term="algorithm" /><category term="CSE214" /><summary type="html"><![CDATA[Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin]]></summary></entry><entry><title type="html">[AL] 4. Brute Force and Exhaustive Search</title><link href="http://localhost:4000/computerscience/AL-4-Brute-Force-and-Exhaustive-Search-copy/" rel="alternate" type="text/html" title="[AL] 4. Brute Force and Exhaustive Search" /><published>2022-05-01T00:00:00+09:00</published><updated>2022-05-01T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/%5BAL%5D%204%20Brute%20Force%20and%20Exhaustive%20Search%20copy</id><content type="html" xml:base="http://localhost:4000/computerscience/AL-4-Brute-Force-and-Exhaustive-Search-copy/"><![CDATA[<blockquote>
  <p>Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin</p>
</blockquote>

<h1 id="brute-force">Brute Force</h1>
<p>문제를 해결하기 위한 간단한 접근 방식이며, 보통 문제의 문장과 관련된 개념의 정의에 직접적으로 기초한다.</p>

<p>영리하거나 효율적인 알고리즘의 소스가 되는 경우는 드물지만 Brute force는 중요한 알고리즘 디자인 전략으로써 간과해선 안된다.</p>
<ol>
  <li>매우 다양한 문제에 적용될 수 있다.</li>
  <li>어떤 중요한 문제에 대해 적어도 입력의 크기에 제한 없는 실제적인 값에 의미있는 알고리즘이 된다.
    <ul>
      <li>ex) sorting, searching, matrix multiplication, string matching</li>
    </ul>
  </li>
  <li>적은 수의 입력만 해결할 필요가 있고 허용할만한 속도로 해결할 수 있다면 더 효율적인 알고리즘을 만들기 위해 비용을 들이지 않아도 된다.</li>
  <li>일반적으로 매우 비효율적이더라도 작은 크기의 입력을 가진 문제를 푸는데 있어서 유용할 수 있다.</li>
  <li>더욱 효율적인 대안을 판단하는 기준으로 이론적, 교육적 목적을 제공한다.</li>
</ol>

<h2 id="sorting">Sorting</h2>

<h3 id="selection-sort">Selection sort</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM SelectionSort(A[0..n-1])
    //Input: An array A[0..n-1] of orderable elements
    //Output: Array A[0..n-1] sorted in nondecreasing order
    for i &lt;- 0 to n-2 do
        min &lt;- i
        for j &lt;- i+1 to n-1 do
            if A[j] &lt; A[min] min &lt;- j
        swap A[i] and A[min]
</code></pre></div></div>
<ul>
  <li>Input Size: The number of elements, n</li>
  <li>Basic operation: The key comparison
  \(C(n)=\sum^{n-2}_{i=0}\sum^{n-1}_{j=i+1}1==\sum^{n-2}_{i=0}(n-1-i)={(n-1)n\over 2}\)</li>
  <li>모든 입력에서 $\Theta(n^2)$</li>
  <li>key의 swap은 $n-1$번만 일어난다. 이것은 다른 정렬 알고리즘과 비교하였을 때 좋은 점이다.</li>
</ul>

<h3 id="bubble-sort">Bubble sort</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM BubbleSort(A[0..n-1])
    //Input: An array A[0..n-1] of orderable elements
    //Output: Array A[0..n-1] sorted in nondecreasing order
    for i &lt;- 0 to n-2 do
        for j &lt;- n-2-i to n-1 do
            if A[j+1] &lt; A[j] swap A[j] and A[j+1]
</code></pre></div></div>
<ul>
  <li>key comparison 횟수는 모든 입력에 대해 동일하나 swap 횟수는 입력에 따라 달라진다.</li>
  <li>worst case에서 swap 횟수와 comparison 횟수가 같다</li>
  <li>각 반복에서 교환이 한번도 일어나지 않았다면 알고리즘을 멈추는것으로 개선할 수 있다.</li>
</ul>

<h2 id="search">Search</h2>

<h3 id="sequential-search">Sequential Search</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM SequentialSearch2(A[0..n],K)
    //Input: An Array A of n elements and a search key K
    //Output: The index of the first element in A[0..n-1] whose value is equal to K or -1 if no such element is found
    A[n] &lt;- K
    i &lt;- 0
    while A[i] != K do
        i &lt;- i+1
    if i &lt; n return i
    else return -1 
</code></pre></div></div>
<ul>
  <li>배열이 정렬되어 있다면 요소가 search key보다 크거나 같아진다면 알고리즘을 멈추는 것으로 개선할 수 있다.</li>
</ul>

<h3 id="string-matching">String matching</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM BruteForceStringMatch(T[0..n-1], P[0..m-1])
    //Input: An array T[0..n-1] of n characters representing a text and
             An array P[0..m-1] of m characters representing a pattern
    //Output: The index of the first character in the text that starts a matching substring or -1 if the search is unsuccessful
    for i &lt;- 0 to n-m do
        j &lt;- 0
        while j &lt; m and P[j] = T[i+j] do
            j &lt;- j+1
        if j = m return i
    return -1    
</code></pre></div></div>
<ul>
  <li>최악의 경우 이 알고리즘은 $m(n-m+1)$개의 character를 비교해야하고 이것은 $O(nm)이다.</li>
  <li>그러나 일반적인 자연어 텍스트의 경우 대부분 매우 적은 비교 이후 <code class="language-plaintext highlighter-rouge">i</code>의 이동이 일어날 것으로 기대해야한다.</li>
  <li>랜덤 텍스트에서 검색할 경우 $\Theta(n)$로 보였다.</li>
</ul>

<h2 id="geometric-problems">Geometric problems</h2>

<h3 id="closest-pair-problem">Closest-Pair Problem</h3>
<p>점들의 집합에서 가장 가까운 두 점을 찾기.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM BruteForceClosestPair(P)
    //Input: A list P of n (n&gt;=2) points p1(x1,y1),...,pn(xn,yn)
    //Output: The distance between the closest pair of points
    d &lt;- ∞
    for i &lt;- 1 to n-1 do
        for j &lt;- i+1 to n do
            d &lt;- min(d, sqrt((xi-xj)^2 + (yi-yj)^2))
    return d
</code></pre></div></div>
<ul>
  <li>Basic operation: computing the sqrt -&gt; squaring a number
  \(C(n)=\sum^{n-1}_{i=1}\sum^{n}_{j=i+1}2 = 2\sum^{n-1}_{i=1}(n-i)=n(n-1)\in\Theta(n^2)\)</li>
</ul>

<h3 id="convex-hull-problem">Convex-Hull Problem</h3>
<p>평면 또는 고차워너 공간의 특정 점 집합에서 볼록 껍질 찾기.</p>
<ul>
  <li>컴퓨터 기하학에서 가장 중요한 문제들 중 하나이다.</li>
  <li>볼록 껍질은 주어진 물체의 모양과 데이터 셋에 가까운 근사치를 제공한다.</li>
  <li>정의
    <ul>
      <li>공간상에서 점들의 집합(유한 or 무한)의 어느 두 점 $p$와 $q$에 대해 $p$와 $q$의 끝점을 연결한 선분들이 모두 집합에 속한다면 Convex한다고 한다.</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/%5BAL%5D4/convexhull.png" alt="convexhull" width="70%" height="70%" /></p>

<ul>
  <li>Algorithm
    <ul>
      <li>두 점 $(x_1,\ y_1),\ (x_2,\ y_2)$을 지나는 직선은 다음과 같이 정의된다
\(ax+by=c\)
\(a=y_2-y_1,\ b=x_1=x_2,\ c=x_1y_2-y_1x_2\)</li>
      <li>이 직선의 방정식은 평면을 $ax+by&gt;c$ 와 $ax+by&lt;c$ 두개의 평면으로 나눈다.</li>
      <li>모든 점들이 같은 평면에 있다면 그 직선을 선택한다.
        <ul>
          <li>$ax+by-c$의 부호를 확인하는 방법을 사용한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Time efficiency : $O(n^3)$</li>
</ul>

<h1 id="exhaustive-search">Exhaustive Search</h1>
<h2 id="combinational-problems">Combinational problems</h2>

<h3 id="tsp">TSP</h3>
<p>최소비용으로 모든 도시를 여행하는 방법을 찾는 문제
<img src="/assets/img/%5BAL%5D4/TSP.png" alt="TSP" width="70%" height="70%" /></p>
<ul>
  <li>The total number of permutations : ${1\over2}(n-1)!$</li>
</ul>

<h3 id="knapsack-problem">Knapsack problem</h3>
<p>weight $w_i$, value $v_i$를 가진 $n$개의 아이템의 부분집합 중 가방에 담을 수 있는 가장 비싼 집합을 찾는 문제
<img src="/assets/img/%5BAL%5D4/knapsack1.png" alt="knapack" width="50%" height="50%" /> 
<img src="/assets/img/%5BAL%5D4/knapsack2.png" alt="knapack" width="40%" height="40%" /></p>
<ul>
  <li>모든 부분집합을 만들고 가방에 담을 수 있는 부분 집합 중 가장 비싼 부분집합을 선택한다.</li>
  <li>The number of subsets of an n-element set is $2^n$
    <ul>
      <li>$\Omega(2^n)$ algorithm</li>
    </ul>
  </li>
</ul>

<h3 id="assigntment-problem">Assigntment problem</h3>
<p>$n$명의 사람에게 $n$개의 일을 한 사람 당 하나씩 최소 비용으로 부여하는 문제
<img src="/assets/img/%5BAL%5D4/assign.png" alt="assign" width="100%" height="100%" /></p>

<p><img src="/assets/img/%5BAL%5D4/assign2.png" alt="assign2" height="100%" /></p>
<ul>
  <li>가능한 모든 순열을 구한 뒤 각 순열마다 비용을 구해 최소값을 갖는 순열을 찾는다.</li>
</ul>]]></content><author><name>Junhwan</name></author><category term="ComputerScience" /><category term="algorithm" /><category term="CSE214" /><summary type="html"><![CDATA[Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin]]></summary></entry><entry><title type="html">[AL] 3. Fundamentals of the Analysis of Algorithm Efficiency</title><link href="http://localhost:4000/computerscience/AL-3-Fundamentals-of-the-Analysis-of-Algorithm-Efficiency/" rel="alternate" type="text/html" title="[AL] 3. Fundamentals of the Analysis of Algorithm Efficiency" /><published>2022-05-01T00:00:00+09:00</published><updated>2022-05-01T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/%5BAL%5D%203%20Fundamentals%20of%20the%20Analysis%20of%20Algorithm%20Efficiency</id><content type="html" xml:base="http://localhost:4000/computerscience/AL-3-Fundamentals-of-the-Analysis-of-Algorithm-Efficiency/"><![CDATA[<blockquote>
  <p>Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin</p>
</blockquote>

<h2 id="efficiency">Efficiency</h2>
<ul>
  <li>시간 효율성 (시간 복잡도) : 문제에서 알고리즘이 얼마나 빨리 실행되는지를 의미한다.</li>
  <li>공간 효율성 (공간 복잡도) : 입출력에 필요한 공간 외에 알고리즘에 필요한 메모리 단위의 양을 의미한다.
현재 일반적으로 알고리즘에 필요한 추가 공간의 양은 크게 중요하지 않다. 대부분의 문제에서 공간보다 속도에서 훨씬 더 눈부신 발전을 이룰 수 있다.</li>
</ul>

<h2 id="time-efficiency">Time efficiency</h2>

<h3 id="measuring-an-algorithms-running-time">Measuring an algorithm’s running time</h3>
<ul>
  <li>프로그램의 실행시간 측정
    <ul>
      <li>특정 컴퓨터의 속도에 의존</li>
      <li>알고리즘을 구현하는 프로그램의 성능과 기계 코드를 생성하는 데 사용되는 컴파일러의 성능에 의존된다.</li>
      <li>프로그램의 실제 실행 시간을 측정하는 것은 어렵다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">basic operation</code>이 실행되는 횟수를 세는 방법
    <ul>
      <li>알고리즘의 <code class="language-plaintext highlighter-rouge">basic operation</code>을 확인하고 이것이 실행되는 횟수를 계산한다.</li>
      <li><code class="language-plaintext highlighter-rouge">Basic operation</code> : 총 실행 시간에 가장 많이 기여하는 작업 (일반적으로 일고리즘의 가장 안쪽 루프에서 가장 시간이 많이 걸리는 작업)
        <ul>
          <li>Example
            <ul>
              <li>정렬 알고리즘에서의 <code class="language-plaintext highlighter-rouge">key comparision</code></li>
              <li>수학적 문제에서의 사칙연산</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="tn">$T(n)$</h3>

<p>$n$ : input size, $T(n)$ : running time,  $c_{op}$ : execution time for basic operation, $C(n)$ : Number of times basic operation is executed
\(T(n) \approx c_{op}C(n)\)</p>

<h3 id="efficiency-on-particular-input">Efficiency on particular input</h3>
<ul>
  <li>특정 입력에 따라 효율성이 달라지는 알고리즘이 있다.
    <ul>
      <li>Sequencial search</li>
    </ul>
  </li>
  <li>The worst-case efficiency $C_{worst}(n)$
    <ul>
      <li>크기가 <code class="language-plaintext highlighter-rouge">n</code>인 모든 입력 중 가장 느리게 실행회는 worst-case의 efficiency.</li>
      <li>크기가 <code class="language-plaintext highlighter-rouge">n</code>인 입력에 대해 실행시간이 $C_{worst}(n)$를 초과하지 않음을 보장한다.</li>
    </ul>
  </li>
  <li>The best-case efficiency $C_{best}(n)$
    <ul>
      <li>크기가 <code class="language-plaintext highlighter-rouge">n</code>인 모든 입력 중 가장 빠르게 실행되는 best-case의 efficiency.</li>
      <li>best-case efficiency에 대한 분석은 worst-case efficiency에 대한 분석만큼 중요하진 않지만 완전히 쓸모 없는 것은 아니다.</li>
    </ul>
  </li>
  <li>The average-case efficiency $C_{avg}(n)$
    <ul>
      <li>average-case efficiency는 best-case 및 worst-case의 efficiency 조사보다 상당히 어렵다.</li>
    </ul>
  </li>
</ul>

<h4 id="sequencial-search">Sequencial search</h4>
<p>Pseudo code</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algorithm SequentialSearch(A[0..n-1], K)
    i &lt;- 0
        while i&lt;n and A[i]!=K do
            i &lt;- i+1
    if i &lt; n return i
    else return -1

</code></pre></div></div>

<ul>
  <li>$C_{worst}(n) = n$</li>
  <li>$C_{best}(n) = 1$</li>
  <li>$C_{avg}(n)$
    <ul>
      <li>$\sum_{i=1}^{n}({p \over n}i)+n(1-p) =  {p(n+1) \over 2}+n(1-p)$</li>
      <li>if $p=1$, $C_{avg}(n) = {n+1 \over 2}$</li>
      <li>if $p=0$, $C_{avg}(n) = n$</li>
    </ul>
  </li>
</ul>

<h3 id="asymptotic-order-of-growth">Asymptotic order of growth</h3>
<h4 id="ogn">$O(g(n))$</h4>
<p>$g(n)$보다 작거나 같은 증가율 가진 함수들의 집합
<img src="/assets/img/%5BAL%5D3/BigO.png" alt="bigO" width="70%" height="70%" /></p>

\[t(n) \in O(g(n))\]

\[^\exists c&gt;0 \quad s.t. \quad t(n) \le cg(n) \ for \ all \ n \ge n_0\]

<h4 id="omegagn">$\Omega(g(n))$</h4>
<p>$g(n)$보다 크거나 같은 증가율 합수들의 집합</p>

<p><img src="/assets/img/%5BAL%5D3/BigOmega.png" alt="bigOmega" width="70%" height="70%" /></p>

\[t(n) \in \Omega(g(n))\]

\[^\exists c &gt;0 \quad s.t. \quad t(n) \ge cg(n) \quad for \ \  all \ \  n \ge n_0\]

<h4 id="thetagn">$\Theta(g(n))$</h4>
<p><img src="/assets/img/%5BAL%5D3/BigTheta.png" alt="bigTheta" width="70%" height="70%" /></p>

<p>$g(n)$과 같은 증가율을 가진 함수들의 집합</p>

\[t(n) \in \Theta(g(n))\]

\[^\exists c_1, \ c_2&gt;0 \quad s.t. \quad  c_1g(n) \le t(n) \le c_2g(n) \quad for \ \  all \ \  n \ge n_0\]

<h4 id="using-limits-for-comparing-orders-of-grouth">Using limits for comparing orders of grouth</h4>

\[\lim_{n\rightarrow \infty}=\begin{cases}0\quad implies\ that\ t(n)\ has \ a\ smaller\ order\ of\ growth\ than\ g(n)\\c \quad implies\ that\ t(n)\ has \ the\ same\ order\ of\ growth\ as\ g(n) \\\infty \quad implies\ that\ t(n)\ has \ a\ larger\ order\ of\ growth\ as\ g(n) \end{cases}\]

<ul>
  <li>첫번째 두 경우는 $t(n) \in O(g(n))$을 의미한다</li>
  <li>마지막 두 경우는  $t(n) \in \Omega(g(n))$을 의미한다</li>
  <li>두번째 경우는  $t(n) \in \Theta(g(n))$을 의미한다</li>
</ul>

<h3 id="nonrecursive-algorithms">Nonrecursive algorithms</h3>

<h4 id="example-1-maximum-element">Example 1: Maximum element</h4>
<ul>
  <li>Pseudo code
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ALGORITHM MaxElement(A[0...n-1])
      maxval &lt;- A[0]
      for i &lt;- 1 to n-1 do
          maxval &lt;- A[i]
      return maxval
</code></pre></div>    </div>
  </li>
  <li>Input size : the numver of elements in the array, n</li>
  <li>Basic operation : comparison</li>
  <li>
\[C(n) = \sum^{n-1}_{i=1}1=n-1\in\Theta(n)\]
  </li>
</ul>

<h4 id="example-2-element-uniqueness-problem">Example 2: Element uniqueness problem</h4>
<ul>
  <li>Pseudo code
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ALGORITHM UniqueElements(A[0...n-1])
      for i &lt;- 0 to n-2 do
          for j &lt;- i+1 to n-1 do
              if A[i] = A[j] return false
      return true
</code></pre></div>    </div>
  </li>
  <li>Input size : the numver of elements in the array, n</li>
  <li>Basic operation : comparison</li>
  <li>The worst cases:
    <ul>
      <li>배열에 같은 원소가 없는 경우</li>
      <li>마지막 두 원소가 같은 경우
\(C_{worst}(n) = \sum^{n-2}_{i=0}\sum_{j=i+1}^{n-1}1=\sum^{n-2}_{i=0}(n-i-1)={n(n-1)\over2}\approx{1\over2}n^2\in\Theta(n^2)\)</li>
    </ul>
  </li>
</ul>

<h4 id="example-3-matrix-multiplication">Example 3: Matrix multiplication</h4>
<p align="center">
	<img src="/assets/img/%5BAL%5D3/matrix.png" alt="kingdom" width="70%" height="70%" />
</p>
<ul>
  <li>Pseudo code
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ALGORITHM MatrixMultiblication(A[0...n-1])
      for i &lt;- 0 to n-1 do
          for j &lt;- 0 to n-1 do
              C[i,j] &lt;- 0.0
              for k &lt;- 0 to n-1 do
                  C[i,j] &lt;- C[i,j] + A[i,k]*B[k,j]
      return C
</code></pre></div>    </div>
  </li>
  <li>Input size : the numver of elements in the array, n</li>
  <li>Basic operation : multiplication and addition</li>
</ul>

<center>$$M(n) = \sum^{n-1}_{i=0}\sum^{n-1}_{j=0}\sum^{n-1}_{k=0}= \sum^{n-1}_{i=0}\sum^{n-1}_{j=0}n=\sum^{n-1}_{i=0}n^2=n^3$$
$$T(n) \approx c_mM(n)+c_aM(n)=(c_m+c_a)n^3$$</center>

<h4 id="example-4-counting-binary-digits">Example 4: Counting binary digits</h4>
<ul>
  <li>Pseudo code
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ALGORITHM Binary(n)
      count &lt;- 1
      while n&gt;1 do
          count &lt;- count+1
          n &lt;- ⌊n/2⌋
      return count
</code></pre></div>    </div>
  </li>
  <li>Basic operation : comparison</li>
  <li>The total number of comparison : $\lfloor \log_2n\rfloor+1$</li>
</ul>

<h3 id="recursive-algorithms">Recursive algorithms</h3>

<h4 id="example-1-maximum-element-1">Example 1: Maximum element</h4>
<ul>
  <li>Pseudo code
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ALGORITHM F(n)
      if n=0 return 1
      else return F(n-1) * n
</code></pre></div>    </div>
  </li>
  <li>Input size : n</li>
  <li>Basic operation : multiplication
\(M(n) = M(n-1) + 1 \quad  for \quad n&gt;0,\quad M(0) =0\)
\(M(n) = M(n-1) + 1 =\ \cdots\ = M(n-n)+n=n\)</li>
</ul>

<h4 id="example-2-tower-of-hanoi-puzzle">Example 2: Tower of Hanoi puzzle</h4>
<p><img src="/assets/img/%5BAL%5D3/hanoi.png" alt="hanoi" width="70%" height="70%" /></p>
<ul>
  <li>Input size : the number of disks, n</li>
  <li>Basic operation : moving one disk</li>
</ul>

<p>\(M(n) = 2M(n-1) + 1 \quad  for \quad n&gt;1, \quad M(1)=1\)
\(M(n) = 2M(n-1) + 1 = 2[2M(n-2) + 1]+1 =\ \cdots\ = 2^{n-1}M(n-(n-1))+2^{n-1}-1=2^n-1\)</p>

<h4 id="example-3-counting-binary-digits-recursion">Example 3: Counting binary digits (recursion)</h4>
<ul>
  <li>Pseudo code
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ALGORITHM BinRec(n)
      if n=1 return 1
      else return BinRec(⌊n/2⌋)+1
</code></pre></div>    </div>
  </li>
  <li>The total number of additions : $A(n)$</li>
  <li>Recurrence : $A(n) = A(\lfloor {n\over2} \rfloor ) + 1$ for $n&gt;1$</li>
  <li>Initial condition: $A(1)=0$</li>
  <li>Smoothness rule</li>
</ul>

\[n=2^k\quad\quad\]

\[A(2^k)=A(2^{k-1})+1\quad for\quad k&gt;0,\quad A(2^0)=0\]

\[A(2^k) = A(2^{k-k})+k = A(1) + k = k\]

\[n=2^k,\quad k=\log_2n\]

\[A(n) = \log_2n\in\Theta(\log n)\]

<h4 id="example-4-computing-the-nth-fibonacci-number">Example 4: Computing the nth Fibonacci number</h4>
<ul>
  <li>Pseudo code
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ALGORITHM F(n)
      if n&lt;=1 return n
      else return F(n-1) + F(n-2)
</code></pre></div>    </div>
  </li>
  <li>Basic operation : addition</li>
  <li>The total number of additions : $A(n)$
    <ul>
      <li>
        <p>$A(2^k)=A(n-1)+A(n-2)+1\quad for\quad n&gt;1$</p>

        <p>$A(0)=0,\quad A(1)=0$</p>

        <p>$A(n) - A(n-1)-A(n-2)=1$</p>

        <p>$[A(n)+1]-[A(n-1)+1]-[A(n-2)+1]=0$</p>

        <p>$B(n) = A(n)+1$</p>

        <p>$B(n) - B(n-1)-B(n-2)=0,\quad B(0)=1,\quad B(1)=1$</p>

        <p>$B(n)={1\over \sqrt5}(\phi ^{n+1} - \hat\phi^{n+1} )$</p>

        <p>$A(n)={1\over \sqrt5}(\phi ^{n+1} - \hat\phi^{n+1} )-1 \in\Theta(\phi^n)$</p>
      </li>
    </ul>
  </li>
  <li>$\Theta(\log n)$ algorithm
    <ul>
      <li>\(\left[\begin{matrix}F(n-1) &amp; F(n) \\ F(n) &amp; F(n+1)\end{matrix}\right] = \left[ \begin{matrix}0&amp;1\\1&amp;1\end{matrix}\right]^n\)
for $n\ge1$</li>
    </ul>
  </li>
</ul>]]></content><author><name>Junhwan</name></author><category term="ComputerScience" /><category term="algorithm" /><category term="CSE214" /><summary type="html"><![CDATA[Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin]]></summary></entry><entry><title type="html">[AL] 1. Intro</title><link href="http://localhost:4000/computerscience/AL-1.-Intro/" rel="alternate" type="text/html" title="[AL] 1. Intro" /><published>2022-04-30T00:00:00+09:00</published><updated>2022-04-30T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/%5BAL%5D%201.%20Intro</id><content type="html" xml:base="http://localhost:4000/computerscience/AL-1.-Intro/"><![CDATA[<blockquote>
  <p>Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin</p>
</blockquote>

<h2 id="algorithm을-공부해야하는-이유">Algorithm을 공부해야하는 이유</h2>

<h3 id="컴퓨터-전문가가-되려고-하는-학생이라면">컴퓨터 전문가가 되려고 하는 학생이라면</h3>
<ul>
  <li>실용적인 이유
    <ul>
      <li>다양한 컴퓨팅 분야의 중요한 Algorithm의 표준적인 집합을 알아야한다.</li>
      <li>새로운 Algorithm을 디자인하고 효율성을 분석할 수 있어야 한다.</li>
    </ul>
  </li>
  <li>이론적인 이유
    <ul>
      <li>algorithmics은 컴퓨터 과학의 기반이다.</li>
    </ul>
  </li>
</ul>

<h3 id="computing-related-학생이-아니라면">computing-related 학생이 아니라면</h3>
<ul>
  <li>Algorithm이 없는 컴퓨터 프로그램은 존재하지 않는다.</li>
  <li>컴퓨터 어플리케이션이 우리의 직업적, 개인적인 삶의 거의 모든 면에서 필수불가결해지면서, Algorithm을 공부하는 것은 점점 더 많은 사람들에게 필수가 됨</li>
</ul>

<p><strong>Algorithm을 공부하는 것은 분석 기술을 기르는데 유용하다.</strong></p>

<h2 id="what-is-an-algorithm">What is an algorithm</h2>

<p>An algorithm is a sequence of unambiguous instructions for solving a problem, i.e., for obtaining a required output for any legitimate input in a finite amount of time.</p>

<p>Algorithm은 문제를 해결하기 위한 명확한 명령의 연속이다. 즉, 제한된 시간 내에 모든 허용된 입력에 필요한 출력을 얻기 위한 것이다.</p>

<h2 id="algorithm의-특징">Algorithm의 특징</h2>
<p>The nonambiguity requirement for each step of an algorithm cannot be compromised.</p>

<p>각 단계는 애매하지 않아야한다.</p>

<p>The range of inputs for which an algorithm works has to be specified carefully.</p>

<p>Algorithm이 작동하는 입력의 범위가 구체적으로 명시 되어야한다.</p>

<p>The same algorithm can be represented in several different ways.</p>

<p>같은 Algorithm은 여러 방법으로 표현될 수 있다.</p>

<p>There may exist several algorithms for solving the same problem.</p>

<p>같은 문제를 푸는 Algorithm은 다양하게 존재할 수 있다.</p>

<p>Algorithms for the same problem can be based on very different ideas and can solve the problem with dramatically different speeds.</p>

<p>같은 문제의 Algorithm은 매우 다른 아이디어에 기반될 수 있고 문제를 푸는 속도가 많이 차이날 수 있다.</p>

<h2 id="algorithm의-성질">Algorithm의 성질</h2>
<ul>
  <li>Finiteness
    <ul>
      <li>terminates after a finite number of steps</li>
      <li>유한한 개수의 명령 후에 끝이 나야한다.</li>
    </ul>
  </li>
  <li>Definiteness
    <ul>
      <li>rigorously and unambiguously specified</li>
      <li>엄격해야하고 중의적이지 않아야한다.</li>
    </ul>
  </li>
  <li>Clearly specified input
    <ul>
      <li>valid inputs are clearly specified</li>
      <li>입력이 명확하게 명시되어야한다.</li>
    </ul>
  </li>
  <li>Clearly specified/expected output
    <ul>
      <li>can be proved to produce the correct output given a valid input</li>
      <li>유효한 입력이 주어졌을 때 정확한 출력을 만들어 냈는지 증명할 수 있어야한다.</li>
    </ul>
  </li>
  <li>Effectiveness
    <ul>
      <li>steps are sufficiently simple and basic</li>
      <li>각 단계가 충분히 간단하고 기본적이어야한다.</li>
    </ul>
  </li>
</ul>

<h2 id="최대공약수-구하기">최대공약수 구하기</h2>
<h3 id="유클리드-algorithm">유클리드 Algorithm</h3>

<p><strong>Eclid’s algorithm</strong> for computing `gcd(m,n)</p>

<p><strong>Step 1</strong> 만약 <code class="language-plaintext highlighter-rouge">n=0</code> 이면 정답으로 <code class="language-plaintext highlighter-rouge">m</code>을 리턴하고 멈춘다.; 아니라면 <strong>Step 2</strong>를 진행한다.</p>

<p><strong>Step 2</strong> <code class="language-plaintext highlighter-rouge">m</code>을 <code class="language-plaintext highlighter-rouge">n</code>으로 나눈 나머지를 <code class="language-plaintext highlighter-rouge">r</code>에 할당한다.</p>

<p><strong>Step 3</strong> <code class="language-plaintext highlighter-rouge">n</code>을 <code class="language-plaintext highlighter-rouge">m</code>에 할당하고 <code class="language-plaintext highlighter-rouge">r</code>을 <code class="language-plaintext highlighter-rouge">n</code>에 할당한 뒤 <strong>Step 1</strong>로 돌아간다.</p>

<p>pseudo code</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//Inputs: Two nonegative, not-both-zero integers m and n
//OUtput: Greatest common divisor of m and n
Euclid(m,n)
  while n!=0 do
    r = m mod n
    m = n
    n = r
  return m
</code></pre></div></div>

<h3 id="consecutive-integer-checking-algorithm">Consecutive integer checking algorithm</h3>
<p><strong>Step 1</strong> <code class="language-plaintext highlighter-rouge">t</code>에 <code class="language-plaintext highlighter-rouge">min(m.n)</code>을 할당한다</p>

<p><strong>Step 2</strong> <code class="language-plaintext highlighter-rouge">m</code>을 <code class="language-plaintext highlighter-rouge">t</code>로 나누고 나머지가 <code class="language-plaintext highlighter-rouge">0</code>이라면 <strong>Step 3</strong>로 가고 아니면 <strong>Step 4</strong>로 간다.</p>

<p><strong>Step 3</strong> <code class="language-plaintext highlighter-rouge">n</code>을 <code class="language-plaintext highlighter-rouge">t</code>로 나누고 나머지가 <code class="language-plaintext highlighter-rouge">0</code>이라면 <code class="language-plaintext highlighter-rouge">t</code>를 정답으로 리턴하고 멈춘다. 아니라면 <strong>Step 4</strong>로 간다.</p>

<p><strong>Step 4</strong> <code class="language-plaintext highlighter-rouge">t</code>를 1 감소시키고 <strong>Step 2</strong>로 간다.</p>

<p>이 Algorithm은 입력값이 0일 때 제대로 작동하지 않는다.</p>

<h3 id="소인수-분해">소인수 분해</h3>
<p><strong>Step 1</strong> <code class="language-plaintext highlighter-rouge">m</code>을 소인수를 찾아라</p>

<p><strong>Step 2</strong> <code class="language-plaintext highlighter-rouge">n</code>을 소인수를 찾아라</p>

<p><strong>Step 3</strong> <strong>Step 1</strong>과 <strong>Step 2</strong>에서 공통으로 나오는 소인수를 찾아라</p>

<p><strong>Step 4</strong> 모두 곱해라</p>

<p>소인수 분해를 하는 방법이 unambiguously하게 정의되어 있지 않아 좋은 Algorithm 기술방법이 아니다.</p>

<h3 id="understanding-the-problem">Understanding the problem</h3>
<ul>
  <li>Algorithm을 디자인하기 전 첫번째로 해야하는 것은 주어진 문제를 충분히 이해하는 것이다.
    <ul>
      <li>문제 설명을 조심스럽게 읽는다.</li>
      <li>문제에 대해 조금이라도 의문이 있다면 질문한다.</li>
      <li>손으로 몇가지 작은 예시들을 풀어본다</li>
      <li>특이 케이스를 생각해본다.</li>
      <li>필요하다면 다시 질문해본다.</li>
    </ul>
  </li>
  <li>컴퓨터 응용프로그램에서 자주 발생하는 몇가지 문제들이 있다.
    <ul>
      <li>이런 문제라면 이미 알려진 Algorithm을 사용한다.</li>
      <li>사용 가능한 Algorithm을 찾지 못하면 직접 디자인한다.</li>
    </ul>
  </li>
  <li>
    <p>정확한 Algorithm은 대부분 잘 작동하는 것이 아닌 허용된 모든 입력에 대해 제대로 작동해야한다.
이 단계를 건너 뛴다면 불필요한 작업을 다시해야할 위험이 있다.</p>
  </li>
  <li>디바이스의 능력을 확인해야한다.
    <ul>
      <li>많은 상황에서 작업이 느려지는 것에 대해 걱정하지 않아도 된다.</li>
      <li>하지만 복잡한 문제이거나 거대한 양의 데이터를 작업해야하거나 시간이 큰 영향을 미치는 상황에선 이것은 중요한 문제이다.</li>
    </ul>
  </li>
</ul>

<h3 id="choosing-between-exact-and-approximate-problem-solving">Choosing between Exact and Approximate Problem Solving</h3>
<p>Approximation algorithm을 선택하는 경우</p>
<ol>
  <li>대부분의 경우에서 정확하게 해결할 수 없는 중요한 문제들이 있다.
Ex) 제곱근 구하기, 비선형 방정식 해결 및 유한 적분 계산</li>
  <li>문제를 정확하게 해결하기 위해 사용할 수 있는 Algorithm은 문제의 본질적인 복잡성 때문에 굉장히 느릴 수 있다.
    <ul>
      <li>이것은 특히, 매우 많은 수의 선택과 관련된 많은 문제들에서 발생한다.</li>
    </ul>
  </li>
  <li>근사 Algorithm은 문제를 정확하게 해결하는 Algorithm보다 정교한 Algorithm의 일부가 될 수 있다.</li>
</ol>

<h3 id="algorithm-설계-전략">Algorithm 설계 전략</h3>
<p>Algorithm 디자인 기술(전략)은 문제를 다양한 컴퓨팅 분야의 다양한 문제에 적용할 수 있는 Algorithm 방식으로 해결하기 위한 일반적인 접근이다.</p>

<h3 id="algorithm과-자료-구조-디자인">Algorithm과 자료 구조 디자인</h3>
<p>Algorithm 디자인 기술은 Algorithm 문제 해결에 대한 강력한 일반 접근 방식을 제공하지만,</p>
<ul>
  <li>특정 문제에 대한 Algorithm을 디자인하는 것은 여전히 ​​어려운 작업일 수 있다.</li>
  <li>일부 디자인 기술은 해당 문제에 단순히 적용할 수 없다.</li>
  <li>때로는 여러 기술을 결합해야 하며 알려진 디자인 기술의 적용으로 정확히 지적하기 어려운 Algorithm이 있다.</li>
</ul>

<p>Algorithm이 수행하는 작업에 적합한 데이터 구조를 선택하는 데 세심한 주의를 기울여야 한다.</p>
<ul>
  <li>Algorithm + 데이터 구조 = 프로그램 [Wir76]</li>
</ul>

<h3 id="algorithm을-표현하는-방법">Algorithm을 표현하는 방법</h3>
<ul>
  <li>natural language (자연어)</li>
  <li>Pesudocode
    <ul>
      <li>자연어와 프로그래밍 언어를 섞은 형태</li>
    </ul>
  </li>
  <li>Flowchart
    <ul>
      <li>복잡한 Algorithm엔 사용하기 어려워 잘 쓰이지 않는다.</li>
    </ul>
  </li>
</ul>

<h3 id="algorithm-correctness-증명">Algorithm Correctness 증명</h3>
<p>모든 허용된 입력에 대하여 제한된 시간안에 필요한 결과를 얻을 수 있는지 증명해야한다.
이 증명은 쉬운 경우도 있고 복잡한 경우도 있다.</p>

<h3 id="algorithm-분석">Algorithm 분석</h3>
<ul>
  <li>Efficiency
    <ul>
      <li>time : 얼마나 빠른지</li>
      <li>space : 메모리를 얼마나 사용하는지</li>
    </ul>
  </li>
  <li>Simplicity
    <ul>
      <li>더욱 간단한 Algorithm은 프로그램하기와 이해하기가 쉽고 가끔 더 효율적이다.</li>
    </ul>
  </li>
  <li>Generality
위의 것들을 만족하지 않으면 다시 디자인해야한다.</li>
</ul>

<h3 id="coding-an-algorithm">Coding an Algorithm</h3>
<p>대부분의 알고리즘의 궁극적인 목적은 컴퓨터 프로그램으로 구현되는 것이다.
알고리즘에서 프로그램으로 잘못 또는 매우 비효율적으로 변환될 위험성이 있다.
실질적인 문제로서, 프로그램의 유효성은 여전히 테스트를 통해 확립된다.
알고리즘을 구현할 때마다 프로그램을 철저히 테스트하고 디버깅해야한다.</p>

<p>일반적으로, 좋은 알고리즘은 반복적인 노력과 재작업의 결과이다.</p>]]></content><author><name>Junhwan</name></author><category term="ComputerScience" /><category term="algorithm" /><category term="CSE214" /><summary type="html"><![CDATA[Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin]]></summary></entry><entry><title type="html">[AL] 2. Important problem types</title><link href="http://localhost:4000/computerscience/AL-2-Important-problem-types/" rel="alternate" type="text/html" title="[AL] 2. Important problem types" /><published>2022-04-30T00:00:00+09:00</published><updated>2022-04-30T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/%5BAL%5D%202%20Important%20problem%20types</id><content type="html" xml:base="http://localhost:4000/computerscience/AL-2-Important-problem-types/"><![CDATA[<blockquote>
  <p>Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin</p>
</blockquote>

<h2 id="sorting">Sorting</h2>
<h3 id="sorting을--하는-이유">Sorting을  하는 이유</h3>
<ul>
  <li>정렬이 출력으로 요구되는 작업이 있다.
    <ul>
      <li>ex) ranking</li>
    </ul>
  </li>
  <li>정렬은 리스트에 대한 질문에 쉽게 대답할 수 있게 해준다
    <ul>
      <li>ex) searching</li>
    </ul>
  </li>
  <li>정렬은 다른 분야의 중요한 알고리즘의 보조 단계로 사용된다.
    <ul>
      <li>ex) geometric algorithms and data compression</li>
    </ul>
  </li>
</ul>

<h3 id="sorting-알고리즘의-예">Sorting 알고리즘의 예</h3>
<ul>
  <li>Selection sort</li>
  <li>Bubble sort</li>
  <li>Insertion sort</li>
  <li>Merge sort</li>
  <li>Heap sort</li>
  <li>…
Sorting 알고리즘의 복잡성은 key의 비교 횟수로 평가한다.</li>
</ul>

<h3 id="sorting-알고리즘의-속성">Sorting 알고리즘의 속성</h3>
<p><code class="language-plaintext highlighter-rouge">stable</code> : 입력에서의 동일한 두 요소의 상대적인 순서가 바뀌지 않는 경우
<code class="language-plaintext highlighter-rouge">in place</code> : 적은 메모리 단위를 제외한 추가 메모리를 사용하지 않는 경우</p>

<h3 id="selection-sort">Selection Sort</h3>
<p>Input : array <code class="language-plaintext highlighter-rouge">a[1]</code>,…,<code class="language-plaintext highlighter-rouge">a[n]</code></p>

<p>Output :  array a sorted in non-decreasing order</p>

<p>Algorithm:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i=1 to n 
    swap a[i] with smallest of a[i],…,a[n] 
</code></pre></div></div>
<p>Pseudocode</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algorithm SelectionSort(A[0..n-1])
//The algorithm sorts a given array by selection sort
//Input: An array A[0..n-1] of orderable elements
//Output: Array A[0..n-1] sorted in ascending order
for i  0 to n – 2 do
	min  i
	for j  i + 1 to n – 1 do
		if A[j] &lt; A[min] 	
			min  j
	swap A[i] and A[min]
</code></pre></div></div>

<h2 id="searching">Searching</h2>
<ul>
  <li>
    <p>주어진 집합(또는 여러 요소가 동일한 값을 가질 수 있도록 허용된 다중 집합)에서 주어진 <code class="language-plaintext highlighter-rouge">search key</code>를 찾는다.</p>
  </li>
  <li>
    <p>Example</p>
    <ul>
      <li>Sequentail search</li>
      <li>Binary search</li>
    </ul>
  </li>
</ul>

<h2 id="string-processing">String processing</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">string</code>: character 배열</li>
  <li><code class="language-plaintext highlighter-rouge">Text strings</code>: letters, numbers, and special characters.</li>
  <li><code class="language-plaintext highlighter-rouge">String matching</code>: 글에서 주어진 단어나 패턴을 검색</li>
</ul>

<h2 id="graph-problems">Graph problems</h2>
<ul>
  <li>실제 문제 모델링
    <ul>
      <li>World Wide Web(WWW) 모델링</li>
      <li>통신망 모델링</li>
      <li>프로젝트 스케줄링</li>
    </ul>
  </li>
  <li>기본적인 그래프 알고리즘
    <ul>
      <li>그래프 순회 알고리즘</li>
      <li>최단거리 알고리즘</li>
      <li>위상정렬</li>
    </ul>
  </li>
</ul>

<h2 id="combinational-problems">Combinational problems</h2>
<ul>
  <li>명시적으로나 암묵적으로 순열, 조합, 부분집합과 같은 <code class="language-plaintext highlighter-rouge">combinatorial object</code>를 찾는것을 요청</li>
  <li>ex) traveling salesman problem (TSP)
    <ul>
      <li>N개 도시를 모두 정확히 한 번 방문하는 최단 기간 찾기</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Combinational</code> 문제는 이론적 및 실제적 관점에서 컴퓨팅에서 가장 어려운 문제이다.</li>
  <li><code class="language-plaintext highlighter-rouge">combinatorial object</code>의 수는 일반적으로 문제의 크기에 따라 매우 빠르게 증가한다.</li>
  <li>제한된 시간안에 정확하게 푸는 알려진 알고리즘이 없다.</li>
</ul>

<h2 id="geometric-problems">Geometric problems</h2>
<ul>
  <li>점, 선, 다각형과 같은 <code class="language-plaintext highlighter-rouge">geometric object</code>를 다룬다.
    <ul>
      <li>응용 : 컴퓨터 그래픽, 로보틱스, 단층 촬영</li>
    </ul>
  </li>
  <li>Example
    <ul>
      <li>The closest-pair problem</li>
      <li>The convex-hull problem</li>
    </ul>
  </li>
</ul>

<h2 id="numerical-problems">Numerical problems</h2>
<ul>
  <li>연속적인 <code class="language-plaintext highlighter-rouge">mathematical objects</code>를 포함하는 문제이다.</li>
  <li>이러한 대부분의 수학적 문제들은 근사적으로만 풀 수 있다.</li>
  <li>근사된 숫자에 대해 산술 연산을 많이 수행하면 반올림 오차가 누적되어 크게 왜곡될 수 있다.</li>
  <li>Example
    <ul>
      <li>방정식</li>
      <li>연립방적식</li>
      <li>정적분</li>
      <li>함수값 계산</li>
    </ul>
  </li>
</ul>]]></content><author><name>Junhwan</name></author><category term="ComputerScience" /><category term="algorithm" /><category term="CSE214" /><summary type="html"><![CDATA[Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin]]></summary></entry><entry><title type="html">[AI] Uniformed Search</title><link href="http://localhost:4000/computerscience/1-Uniformed-Search/" rel="alternate" type="text/html" title="[AI] Uniformed Search" /><published>2022-04-24T00:00:00+09:00</published><updated>2022-04-24T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/1%20Uniformed%20Search</id><content type="html" xml:base="http://localhost:4000/computerscience/1-Uniformed-Search/"><![CDATA[<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>용어 정리
strategy : 전략
complete : solution이 하나 존재 할 때 그 solution을 찾는 것이 보장되어 있는가?
optimal : 최단 경로(the least cost path)를 찾는 것이 보장되어 있는가?   
</code></pre></div></div>

<h1 id="uniformed-search">Uniformed Search</h1>
<h2 id="agents">Agents</h2>
<h3 id="rational-agents">Rational agents</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Rational agent</code>는 명확한 선호도를 가지고 기대치를 통해 불확실성을 모델링하고, 모든 실행 가능한 행동 중 항상 자신에게 최적의 결과를 가져오도록 행동을 수행하도록 선택하는 agent이다.
    <h3 id="reflex-agents">Reflex agents</h3>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Reflex agent</code>s는 현재 상태에 기반을 두어 다음 <code class="language-plaintext highlighter-rouge">action</code>을 선택하는 <code class="language-plaintext highlighter-rouge">agent</code>로 이 Action이 가져올 미래에 대해 고려하지 않는다.</li>
</ul>

<h3 id="planning-agents">Planning agents</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Planning agents</code>는 (가설화된) <code class="language-plaintext highlighter-rouge">sequences of action</code>에 기반을 두어 결정한다.</li>
  <li><code class="language-plaintext highlighter-rouge">World</code>가 <code class="language-plaintext highlighter-rouge">action</code>에 대응하여 어떻게 변해가는지에 대한 모델을 가지고 있다.</li>
</ul>

<h2 id="search">Search</h2>
<h3 id="search-problem">Search Problem</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Search Problem</code>은 <code class="language-plaintext highlighter-rouge">state space</code>(상태 공간), <code class="language-plaintext highlighter-rouge">successor function</code>(후계 함수 action, cost 포함), <code class="language-plaintext highlighter-rouge">start state</code> (시작 상태) 및 <code class="language-plaintext highlighter-rouge">goal test</code>로 구성된다.</li>
  <li>솔루션은 <code class="language-plaintext highlighter-rouge">start state</code>(시작 상태)를 <code class="language-plaintext highlighter-rouge">goal state</code>(목표 상태)로 변환하는 <code class="language-plaintext highlighter-rouge">sequenc of action</code>(plan)이다.</li>
</ul>

<h3 id="state-space-graph">State Space Graph</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">State space graph</code>는 <code class="language-plaintext highlighter-rouge">search problem</code>의 수학적 표현이다. <code class="language-plaintext highlighter-rouge">Node</code>들은 <code class="language-plaintext highlighter-rouge">state</code>를, <code class="language-plaintext highlighter-rouge">arcs</code>는 <code class="language-plaintext highlighter-rouge">action</code>을 나타내며 이것이 가르키는 <code class="language-plaintext highlighter-rouge">node</code>는 그 <code class="language-plaintext highlighter-rouge">action</code>의 결과이다.</li>
  <li>Search graph에서 각 state는 한 번씩 등장한다.</li>
  <li>전체 그래프는 매우 크기 때문에 메모리에 거의 만들 수 없지만 유용한 아이디어이다.</li>
</ul>

<h3 id="search-tree">Search Tree</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Root node</code>는 <code class="language-plaintext highlighter-rouge">start state</code>이고 자녀는 후계자에 해당된다.</li>
  <li><code class="language-plaintext highlighter-rouge">Node</code>가 <code class="language-plaintext highlighter-rouge">state</code>를 표시하지만 이러한 <code class="language-plaintext highlighter-rouge">state</code>를 달성하는 계획에 해당된다.</li>
  <li>대부분의 문제에서 우리는 절대 <code class="language-plaintext highlighter-rouge">tree</code> 전체를 만들 수 없습니다.</li>
</ul>

<h3 id="state-space-graphs-vs-search-trees">State Space Graphs vs Search Trees</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">search tree</code>의 각 <code class="language-plaintext highlighter-rouge">node</code>는 <code class="language-plaintext highlighter-rouge">state space graph</code>의 전체 경로이다.</li>
  <li>우리는 필요에 따라 <code class="language-plaintext highlighter-rouge">tree</code>를 만들고, 가능한 한 적게 만듭니다.</li>
</ul>

<h3 id="depth-first-search">Depth-First Search</h3>
<ul>
  <li>Strategy: expand a a deepest node first</li>
  <li>Implementation: Frontier is a LIFO stack</li>
  <li><strong>Properties</strong> with depth <code class="language-plaintext highlighter-rouge">m</code> tree
    <ul>
      <li>time : $O(bm)$</li>
      <li>space : $O(b^m)$</li>
      <li>Is it complete?
        <ul>
          <li>m could be infinite, so only if we prevent cycles (more later)</li>
        </ul>
      </li>
      <li>Is it optimal?
        <ul>
          <li>No, it finds the “leftmost” solution</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="breath-frist-search">Breath-Frist Search</h3>
<ul>
  <li>Strategy: expand a shallowest node first</li>
  <li>Implementation: Fringe is a FIFO queue</li>
  <li><strong>Properties</strong> with depth <code class="language-plaintext highlighter-rouge">m</code>, shallowest solution’s depth <code class="language-plaintext highlighter-rouge">s</code> tree
    <ul>
      <li>time : $O(b^s)$</li>
      <li>space : $O(b^m)$</li>
      <li>Is it complete?
        <ul>
          <li>Yes, s must be finite if a solution exists</li>
        </ul>
      </li>
      <li>Is it optimal?
        <ul>
          <li>If costs are equal</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="uniform-cost-search">Uniform Cost Search</h3>
<ul>
  <li>Strategy: expand a cheapest node first:</li>
  <li>Implementation: Fringe is a priority queue (priority: cumulative cost)</li>
  <li><strong>Properties</strong> with depth <code class="language-plaintext highlighter-rouge">m</code>, solution costs $C^*$ and arcs cost at least $\epsilon$
    <ul>
      <li>time : $O(b^{C^*/\epsilon})$</li>
      <li>space : $O(b^m)$</li>
      <li>Is it complete?
        <ul>
          <li>Yes, Assuming best solution has a finite cost and minimum arc cost is positive</li>
        </ul>
      </li>
      <li>Is it optimal?
        <ul>
          <li>Yes</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Explores options in every “direction”</li>
  <li>No information about goal location</li>
</ul>]]></content><author><name>Junhwan</name></author><category term="ComputerScience" /><category term="AI" /><category term="COSE361" /><summary type="html"><![CDATA[용어 정리 strategy : 전략 complete : solution이 하나 존재 할 때 그 solution을 찾는 것이 보장되어 있는가? optimal : 최단 경로(the least cost path)를 찾는 것이 보장되어 있는가?]]></summary></entry><entry><title type="html">[수리통계학] Multivariate Probability Distributions</title><link href="http://localhost:4000/statistics/5-Multivariate-Probability-Distributions/" rel="alternate" type="text/html" title="[수리통계학] Multivariate Probability Distributions" /><published>2022-03-07T00:00:00+09:00</published><updated>2022-03-07T00:00:00+09:00</updated><id>http://localhost:4000/statistics/5%20Multivariate%20Probability%20Distributions</id><content type="html" xml:base="http://localhost:4000/statistics/5-Multivariate-Probability-Distributions/"><![CDATA[<h1 id="5-multivariate-probability-distributions">5 Multivariate Probability Distributions</h1>

<hr />

<h2 id="56-special-theorems">5.6 Special Theorems</h2>

<h3 id="theorem-56">THEOREM 5.6</h3>
<blockquote>
  <p>Let $c$ be a constant. Then
\(E(c) = c.\)</p>
</blockquote>

<h3 id="theorem-57">THEOREM 5.7</h3>
<blockquote>
  <p>Let $g(Y1,Y2)$ be a function of the random variables $Y1$ and $Y2$ and let $c$ be a constant. Then
\(E[cg(Y1, Y2)] = cE[g(Y1, Y2)].\)</p>
</blockquote>

<h3 id="theorem-58">THEOREM 5.8</h3>
<blockquote>
  <p>Let $Y1$ and $Y2$ be random variables and $g_1(Y_1,Y_2),\ g_2(Y_1,Y_2),\ \cdots,\ g_k(Y_1,Y_2)$ be functions of $Y_1$ and $Y_2$. Then
\(E[g_1(Y_1,Y_2)\ +\ g2(Y_1,Y_2)\ +\ ···\ +\ g_k(Y_1,Y_2)]
= E[g_1(Y_1,Y_2)]+ E[g_2(Y_1,Y_2)]+\ ···\ +\ E[g_k(Y_1,Y_2)].\)</p>
</blockquote>

<h3 id="theorem-59">THEOREM 5.9</h3>
<blockquote>
  <p>Let $Y_1$ and $Y_2$ be independent random variables and $g(Y_1)$ and $h(Y_2)$ be functions of only $Y_1$ and $Y_2$, respectively. Then
\(E[g(Y_1)h(Y_2)] = E[g(Y_1)]E[h(Y_2)],\)
provided that the expectations exist.</p>
</blockquote>

<hr />

<h2 id="57-the-covariance-of-two-random-variables">5.7 The Covariance of Two Random Variables</h2>

<h3 id="definition-510">DEFINITION 5.10</h3>
<blockquote>
  <p>If $Y_1$ and $Y_2$ are random variables with means $μ_1$ and $μ_2$, respectively, the covariance of $Y_1$ and $Y_2$ is
\(Cov(Y_1, Y_2) = E [(Y_1 − μ_1)(Y_2 − μ_2)] .\)</p>
</blockquote>

<h3 id="theorem-510">THEOREM 5.10</h3>
<blockquote>
  <p>If $Y_1$ and $Y_2$ are random variables with means $μ_1$ and $μ_2$, respectively, then 
\(Cov(Y_1, Y_2) = E [(Y_1 − μ_1)(Y_2 − μ_2)] = E(Y_1Y_2) − E(Y_1)E(Y_2).\)</p>
</blockquote>

<h3 id="theorem-511">THEOREM 5.11</h3>
<blockquote>
  <p>If $Y_1$ and $Y_2$ are independent random variables, then 
\(Cov(Y_1, Y_2) = 0.\)
Thus, independent random variables must be uncorrelated.</p>
</blockquote>

<hr />

<h2 id="58-the-expected-value-and-variance-of-linear-functions-of-random-variables">5.8 The Expected Value and Variance of Linear Functions of Random Variables</h2>

<h3 id="theorem-512">THEOREM 5.12</h3>
<blockquote>
  <p>Let $Y_1,Y_2,…,Y_n$ and $X_1, X_2,…, X_m$ be random variables with $E(Y_i) = μ_i$ and $E ( X_j ) = ξ_j$. Define
\(U_1=\sum^{n}_{i=1}a_iY_i\quad and\quad  U_2=\sum^{n}_{j=1}b_jX_j\)
for constants $a_1,a_2,…,a_n$ and $b_1,b_2,…,b_m.$ Then the following hold:</p>

  <p><strong>a</strong>    $E(U_1)= \sum^n_{i=1}a_iμ_i.$</p>

  <p><strong>b</strong>    $V(U_1) = \sum^n_{i=1} a_i^2V(Y_i) + 2\sum\sum_{ 1≤i&lt;j≤n} a_ia_jCov(Y_i,Y_j)$, where the double sum is over all pairs $(i, j)$ with $i &lt; j$.</p>

  <p><strong>c</strong>    $Cov(U_1,U_2)=\sum_{i=1}^n\sum_{j=1}^m a_ib_jCov(Y_i,X_j)$.</p>
</blockquote>]]></content><author><name>Junhwan</name></author><category term="Statistics" /><category term="MathematicalStatistics" /><category term="STAT232" /><summary type="html"><![CDATA[5 Multivariate Probability Distributions]]></summary></entry></feed>