<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-05-04T13:36:22+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Slow and Steady</title><subtitle>Data Science, Computer Science, Statistics, AI.</subtitle><author><name>Junhwan</name></author><entry><title type="html">[AL] 5. Decrease-and-Conquer</title><link href="http://localhost:4000/computerscience/AL-5-Decrease-and-Conquer/" rel="alternate" type="text/html" title="[AL] 5. Decrease-and-Conquer" /><published>2022-05-02T00:00:00+09:00</published><updated>2022-05-02T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/%5BAL%5D%205%20Decrease-and-Conquer</id><content type="html" xml:base="http://localhost:4000/computerscience/AL-5-Decrease-and-Conquer/"><![CDATA[<blockquote>
  <p>Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin</p>
</blockquote>

<h1 id="decrease-and-conquer">Decrease-and-Conquer</h1>

<h2 id="decrease-and-conquer-technique">Decrease-and-conquer technique</h2>
<p>문제에서 주어진 인스턴스에 대한 솔루션과 더 작은 인스턴스에 대한 솔루션 사이의 관계를 기반으로 문제를 푼다.</p>
<ul>
  <li>하향식(Top down) → 재귀적으로 구현(최종 구현은 비재귀적일 수 있음)</li>
  <li>상향식(Bottom up) → 반복적 구현
    <ul>
      <li>문제의 가장 작은 사례에 대한 해결책부터 시작하여 점진적dmfh 접근</li>
    </ul>
  </li>
</ul>

<h2 id="decrease-by-a-constant">Decrease by a constant</h2>
<p>알고리즘이 반복될 때 마다 인스턴스의 크기를 같은 상수만큼 줄인다. (보통 $1$)
<img src="/assets/img/%5BAL%5D5/decreasebyconstant.png" alt="decreasebyconstant" width="50%" height="50%" /></p>

<h3 id="the-exponentiation-problem">The exponentiation problem</h3>
<p>cmputing $a^n$</p>
<ul>
  <li>Top down
    <ul>
      <li>
\[f(n)=\begin{cases}
f(n-1) \cdot a \quad if\ n&gt;0 \\
1 \qquad\quad\quad\quad\ \ if\ n=0
        
\end{cases}\]
      </li>
    </ul>
  </li>
  <li>Botoom up
    <ul>
      <li>1에서부터 $a$를 $n$번 곱한다.</li>
    </ul>
  </li>
</ul>

<h3 id="insertion-sort">Insertion sort</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM InsertionSort(A[0..n-1])
    //Input: An array A[0..n-1] of n orderalbe elements
    //Output: Array A[0..n-1] sorted in nondecreasing order
    for i &lt;- 1 to n-1 do
        v &lt;- A[i]
        j &lt;- i-1
        while j&gt;=0 and A[j]&gt;v do
            A[j+1] &lt;- A[j]
            j &lt;- j-1
        A[j+1] &lt;- v
</code></pre></div></div>

<p>\(A[0]\le\cdots\le A[j]&lt;A[j+1]\le \cdots \le A[i-1] \ \vert\ A[i]\  \cdots \ A[n-1]\)</p>
<ul>
  <li>basic operation : key comparison <code class="language-plaintext highlighter-rouge">A[j] &gt; v</code></li>
  <li>the worst-case
    <ul>
      <li>
\[C_{worst}(n)=\sum^{n-1}_{i=1}\sum^{i-1}_{j=0}1=\sum^{n-1}_{i=1}i={n(n-1)\over2}\in\Theta(n^2)\]
      </li>
    </ul>
  </li>
  <li>the best-case
    <ul>
      <li>
\[C_{best}(n)=\sum^{n-1}_{i=1}1=n-1\in\Theta(n)\]
      </li>
    </ul>
  </li>
  <li>the average-case
    <ul>
      <li>$$C_{avg}(n)\approx{n^2\over4}\in\Theta(n^2)</li>
    </ul>
  </li>
</ul>

<h3 id="topological-sorting">Topological sorting</h3>
<p><code class="language-plaintext highlighter-rouge">Dag</code> : directed acyclic graph
<code class="language-plaintext highlighter-rouge">Topological sorting</code> : dag의 정점들에 대해 모든 starting 정점이 ending 정점보다 앞에 위치하는 선형적인 순서에 따라 정렬하며 dag에서만 가능하다</p>

<ul>
  <li>Source-removal algorithm : 들어오는 간선이 없는 정점들과 그 정점에서 나가는 간선들을 지워가면서 정렬한다</li>
</ul>

<h2 id="decrease-by-a-constant-factor">Decrease by a constant factor</h2>
<p>알고리즘이 반복될 때 마다 인스턴스의 크기를 같은 상수 factor 만큼 줄인다. (보통 $1/2$)</p>

<p><img src="/assets/img/%5BAL%5D5/decreasebyconstantfactor.png" alt="decreasebyconstantfactor" width="48%" height="48%" /></p>

<h3 id="the-exponentiation-problem-1">The exponentiation problem</h3>
<p>\(a^n= \begin{cases}
    (a^{n/2})^2 \qquad \quad\ \  if\ n\ is\ even\ and\ positive, \\
    (a^{(n-1)/2})^2\cdot a \quad if\ n\ is\ odd\,\\
    1 \qquad\qquad \quad \ \ \ \ if\ n=0
\end{cases}\)</p>

<h3 id="binary-search">Binary search</h3>

<p align="center"><img src="/assets/img/%5BAL%5D5/bs1.png" width="50%" height="50%" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM BinarySearch(A[0..n-1], K)
    //Input: An array A[0..n-1] sorted in ascending order and a search key K
    //Output: An index of the array's element that is equal to k or -1 if there is no such element
    l &lt;- 0; r &lt;- n-1
    while l &lt;= r do
        m &lt;- ⌊(l+r)/2⌋
        if K = A[m] return m
        else if K &lt; A[M] r &lt;- m-1
        else l &lt;- m+1
    return -1 
</code></pre></div></div>

<p>For $K=70$</p>
<p align="center"><img src="/assets/img/%5BAL%5D5/bs2.png" width="60%" height="60%" /></p>

<h3 id="fake-coin-problem">Fake-Coin Problem</h3>

<h3 id="russian-peasant-multiplication">Russian Peasant Multiplication</h3>
<p>두 양수의 곱을 구하는 문제</p>

<p><img src="/assets/img/%5BAL%5D5/RPM.png" width="50%" height="50%" /></p>
<ul>
  <li>$n\cdot m =\begin{cases} {n\over2}\cdot 2m \ {n-1\over2}\cdot 2m + m \end{cases}$</li>
  <li>$1\cdot m = m$ to stop</li>
</ul>

<h2 id="variable-size-decrease">Variable-size decrease</h2>

<h3 id="euclids-algorithm">Euclid’s algorithm</h3>
<p>\(gcd(n,\ m) = gcd(n,\ m\ mod \ n)\)</p>

<h3 id="selection-problem">Selection problem</h3>
<p>$n$개의 원소 중 $k$번째로 작은 수를 찾는 문제</p>
<ul>
  <li>정렬 기반 알고리즘
    <ul>
      <li>Efficiency : $O(n\log n)$</li>
    </ul>
  </li>
  <li>partitioning
    <ul>
      <li><img src="/assets/img/%5BAL%5D5/partitioning.png" width="70%" height="70%" /></li>
    </ul>
  </li>
</ul>

<h4 id="lomuto-partitioning">Lomuto partitioning</h4>
<p><img src="/assets/img/%5BAL%5D5/lomuto.png" width="70%" height="70%" /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM LomutoPartition(A[l..r])
    //Input: A subarray A[1..r] of array A[0..n-1], defined by its left and right indices l and r (l&lt;=r)
    //Output: Partition of A[l..r] and the new position of the pivot
    p &lt;- A[l]
    s &lt;- l
    for i &lt;- l to r do
        if A[i] &lt; p
            s &lt;- s+1; swap(A[s], A[i])
    swap(A[l], A[s])
    return s
</code></pre></div></div>

<ul>
  <li>$s=k-1$ 이라면 문제 해결</li>
  <li>$s&gt;k-1$ 왼쪽에서 $k$번째로 작은 원소 다시 탐색</li>
  <li>$s&lt;k-1$ 오른쪽에서 $(k-s)$번째로 작은 원소 다시 탐색</li>
</ul>

<h4 id="quickselect-algorithm">Quickselect algorithm</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM Quickselect(A[l..r], k)
    //Input: Subarray A[1..r] of array A[0..n-1] of orderable elements and iteger k(1&lt;=k&lt;=r-l+1) 
    //Output: The value of the kth smallest element in A[l..r]
    s &lt;- LomutoPartition(A[l..r]) //or another partition algorithm
    if s=l+k-1 return A[s]
    else if s&gt;l+k-1 Quickselect(A[l..s-1], k)
    else Quickselect(A[s+1..r], l+k-1-s)
</code></pre></div></div>
<ul>
  <li>$C_{best}(n) = n-1 \in \Theta(n).$</li>
  <li>$C_{worst}(n) = (n-1) + (n-2) + \ \cdots\ + 1 = (n-1)n/2 \in \Theta(n^2)$</li>
  <li>$C_{avg}(n) \rightarrow linear$</li>
</ul>

<h3 id="interpolation-search">Interpolation search</h3>
<ul>
  <li>binary search : search key를 항상 정렬된 배열의 중앙값과 비교</li>
  <li>Interpolation search : search key의 값을 고려하여 비교할 값을 정함
    <p align="center"><img src="/assets/img/%5BAL%5D5/interpolation.png" width="70%" height="70%" /></p>
  </li>
</ul>

\[x=l+\lfloor{(v-A[l])(r-l)\over A[r]-A[l]}\rfloor\]

<ul>
  <li>Efficiency
    <ul>
      <li>Basic operation: key comparison</li>
      <li>average case: $C(n)&lt;\log_2\log_2 n +1$</li>
      <li>worst case: $C(n)=n$</li>
    </ul>
  </li>
</ul>

<h3 id="binary-search-tree">Binary Search Tree</h3>
<ul>
  <li>Efficiency
    <ul>
      <li>$C_{worst}(n) = \Theta(n)$</li>
      <li>$C_{avg}(n) = \Theta(\log n)$</li>
    </ul>
  </li>
</ul>

<h2 id="generating-combinatorial-objects">Generating Combinatorial Objects</h2>
<p>Minimal-change requirement</p>
<ul>
  <li>Advantage of this order in TSP</li>
</ul>

<h4 id="johnson-trotter-algorithm">Johnson-Trotter algorithm</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM JohnsonTrotter(n)
    //Input: A positive integer n
    //Output: A list of all permutations of {1,...,n}
    initialize the first permutation with 1(&lt;-)2(&lt;-)...n(&lt;-)
    while the last permutation has a mobile element do
        find its largest mobile element k
        swap k with the adjacent element k's arrow points to
        reverse the direction of all the elements that are larger than k
        add the new permutation to the lis
</code></pre></div></div>
<ul>
  <li>An application of Johnson-Trotter algorithm $(n=3)$
    <p align="center"><img src="/assets/img/%5BAL%5D5/J-T.png" width="70%" height="70%" /></p>
  </li>
  <li>가장 효율적인 generating permutations 알고리즘 중 하나이다.</li>
  <li>Time efficiency: Θ(𝑛!)</li>
</ul>

<h2 id="generating-subsets">Generating Subsets</h2>
<p>Minimal change algorithm</p>

<h3 id="binary-reflected-gray-code-brgc">Binary Reflected Gray Code (BRGC)</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM BRGC(n)
    //Input: A positive integer n
    //Output: A list of all bit strings of length n composing the Gray code
    if n=1 make list L containing bit string 0 and 1 in this order
    else generate list L1 of bit strings of size n-1 by calling BRGC(n-1)
        copy list L1 to list L2 in reversed order
        add 0 in front of each bit string in list L1
        add 1 in front of each bit string in list L2
        append L2 to L1 to get list L
    return L
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">L</code>의 첫번째 원소와 마지막 원소도 1 비트 차이나기 때문에 <code class="language-plaintext highlighter-rouge">cyclic</code>이라고 한다.</li>
</ul>]]></content><author><name>Junhwan</name></author><category term="ComputerScience" /><category term="algorithm" /><category term="CSE214" /><summary type="html"><![CDATA[Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin]]></summary></entry><entry><title type="html">[AL] 6. Divide-and-Conquer</title><link href="http://localhost:4000/computerscience/AL-6-Divide-and-Conquer/" rel="alternate" type="text/html" title="[AL] 6. Divide-and-Conquer" /><published>2022-05-02T00:00:00+09:00</published><updated>2022-05-02T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/%5BAL%5D%206%20Divide-and-Conquer</id><content type="html" xml:base="http://localhost:4000/computerscience/AL-6-Divide-and-Conquer/"><![CDATA[<blockquote>
  <p>Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin</p>
</blockquote>

<h1 id="divide-and-conquer">Divide-and-Conquer</h1>

<h2 id="divide-and-conquer-technique">Divide-and-conquer technique</h2>
<ul>
  <li>가장 잘 알려진 알고리즘 설계 기법이다.</li>
  <li>문제는 같은 유형의 이상적으로 크기가 같은 여러 하위 문제로 나뉜다.</li>
  <li>하위문제는 일반적으로 재귀적으로 해결되고 하위 문제에 대한 솔루션을 결합하여 원래 문에에 대한 솔루션을 구한다.</li>
  <li>Divide-and-conquer technique은 각각의 하위문제를 자체 프로세서에 의해 동시에 해결할 수 있는 병렬 계산에 이상적으로 적합하다.</li>
</ul>

<p align="center"><img src="/assets/img/%5BAL%5D6/dividenconquer.png" width="70%" height="70%" /></p>

<h2 id="general-divide-and-conquer-recurrence">General divide-and-conquer recurrence</h2>
<p>사이즈가 $n$인 인스턴스를 사이즈가 $n/b$인 인스턴스로 나누고 그것을 $a$번 풀어야할 때, $a\ge1$, $b&gt;1$. 
\(T(n)=aT(n/b)+f(n)\)
$f(n)$은 인스턴스를 나누고 합치는데 걸리는 시간에 대한 함수이다.</p>

<h3 id="master-theorem">Master Theorem</h3>

<p>If $f(n)\in\Theta(n^d)$ where $d\ge 0$ in recurrence, then
\(T(n)\in 
\begin{cases} 
\Theta(n^d) \qquad \quad \ if\ a&lt;b^d\\ 
\Theta(n^d\log n) \quad if\ a&lt;b^d\\ 
\Theta(n^{\log_ba})\quad \ \ \ if\ a&lt;b^d
\end{cases}\)</p>

<h2 id="mergesort">Mergesort</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM Mergesort(A[0..n-1])
    //Input: An Array A[0..n-1] of orderable elements
    //Output: Array A[0..n-1] sorted in nondecreasing order
    if n &gt; 1
        copy A[0..⌊n/2⌋-1] to B[0..⌊n/2⌋-1]
        copy A[⌊n/2⌋..n-1] to C[0..⌊n/2⌋-1]
        Mergesort(B[0..⌊n/2⌋-1])
        Mergesort(C[0..⌊n/2⌋-1])
        Merge(B, C, A)

</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM Merge(B[0..p-1], C[0..q-1], A[0..p+q-1])
    //Input: Arrays B[0..p-1] and C[0..q-1] both sorted
    //Output: Sorted array A[0..p+q-1] of the elements of B and C
    i &lt;- 0; j &lt;- 0; k &lt;- 0;
    while i &lt; p and j &lt; q do
        if B[i] &lt;= C[j]
            A[k] &lt;- B[i]; i &lt;- i+1
        else 
            A[k] &lt;- C[j]; j &lt;- j+1
        k &lt;- k+1
    if i = p
        copy C[j..q-1] to A[k..p+q-1]
    else
        copy B[i..p-1] to A[k..p+q-1]    
</code></pre></div></div>

<p align="center"><img src="/assets/img/%5BAL%5D6/mergesort.png" width="70%" height="70%" /></p>

<ul>
  <li>The number of key comparison
    <ul>
      <li>$C(n) = 2C(n/2)+C_{merge}(n)$ for $n&gt;1$, $C(1)=0$</li>
      <li>$C_{merge}(n) = n-1$</li>
      <li>$C_{worst}(n) = 2C_{worst}(n/2)+n-1$ for $n&gt;1$, $C_{worst}(1)=0$</li>
      <li>C_{worst}(n)\in\Theta(n\log n)$</li>
    </ul>
  </li>
  <li>Stable</li>
  <li>Space requirement : $\Theta(n)$ (not in-place)</li>
</ul>

<h2 id="quicksort">Quicksort</h2>
<p align="center"><img src="/assets/img/%5BAL%5D6/quicksort.png" width="70%" height="70%" /></p>
<ul>
  <li>Mergesort가 요소들의 위치에 따라 나눈거라면 Quicksort는 값에 따라 나눈다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM Quicksort(A[l..r])
    //Input: Subarray of array A[0..n-1], defined by its left and right indices l and r
    //Output: Subarray A[l..r] sorted in nondecreasing order
    if l &lt; r
        s &lt;- Partition(A[l..r]) // s is a split position
        Quicksort(A[l..s-1])
        Quicksort(A[s+1..r])
</code></pre></div></div>

<h3 id="partitioning-algorithm">Partitioning Algorithm</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM HoarePartition(A[l..r])
    //Input: Subarray of array A[0..n-1], defined by its left and right indices l and r (l &lt; r)
    //Output: Partition of A[l..r], with the split position returned as this function's value 
    p &lt;- A[l]
    i &lt;- l; j &lt;-  r+1
    repeat
        repeat i &lt;- i+1 until A[i] &gt;= p
        repeat j &lt;- j-1 until A[j] &lt;= q
        swap(A[i], A[j])
    until i &gt;= j
    swap(A[i], A[j]) //undo last swap when i &gt;= j
    swap(A[l], A[j])
    return j
</code></pre></div></div>
<p align="center"><img src="/assets/img/%5BAL%5D6/pa1.png" width="70%" height="70%" /></p>
<p align="center"><img src="/assets/img/%5BAL%5D6/pa2.png" width="70%" height="70%" /></p>
<p align="center"><img src="/assets/img/%5BAL%5D6/pa3.png" width="70%" height="70%" /></p>

<h3 id="analysis-of-quicksort">Analysis of Quicksort</h3>
<ul>
  <li>Best case: 중간에서 split — $\Theta(n\log n)$</li>
  <li>Worst case: 이미 정렬된 배열 — $\Theta(n^2)$</li>
  <li>Average case: random 배열 —$\Theta(n\log n)$
    <ul>
      <li>보통 Mergesort보다 빠르다</li>
    </ul>
  </li>
  <li>Improvements:
    <ul>
      <li>pivot을 선택할 때 세 개의 값중 중간값을 선택</li>
      <li>매우 작은 subarray에서 insertion sort 사용</li>
    </ul>
  </li>
  <li>Not Stable</li>
</ul>

<h2 id="binay-tree">Binay Tree</h2>
<p>Binary trees와 관련된 많은 문제가 divede-and-conquer technique로 해결된다.
<img src="/assets/img/%5BAL%5D6/BT.png" width="70%" height="70%" /></p>

<h3 id="height">Height</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM HEIGHT(T)
    //Input: A binary tree T
    //Output: The height of T
    if T = NULL return -1
    else return max{Height(T_left), Height(T_right)}+1
</code></pre></div></div>
<h3 id="traversals">Traversals</h3>
<ul>
  <li>preorder traversal</li>
  <li>inorder traversal</li>
  <li>postorder traversal</li>
</ul>

<h3 id="multiplication-of-large-integers">Multiplication of Large Integers</h3>

<p>두 자리수 정수$a$, $b$를 $a=a_1a_0$,  $b=b_1b_0$로 나누어 계산한다.</p>

\[c = a*b = c_210^2+c_110^1+c_0\]

<p>$c_2=a_1*b_1$ 첫째 자리수의 곱</p>

<p>$c_0=a_0*b_0$ 둘재 자리 수의 곱</p>

<p>$c_1=(a_1+a_0)*(b_1+b_0)-(c_2+c_0)$ 각 자리수의 합을 곱한 값에 $c_2$, $c_0$를 뺀 값</p>

<p>$n$-자리수의 경우</p>

\[c = a*b = c_210^n+c_110^{n/2}+c_0\]

<p>$c_2=a_1*b_1$ 앞쪽 반의 자리수의 곱</p>

<p>$c_0=a_0*b_0$ 뒷쪽 반의 자리수의 곱</p>

<p>$c_1=(a_1+a_0)*(b_1+b_0)-(c_2+c_0)$ 각 자리수의 합을 곱한 값에 $c_2$, $c_0$를 뺀 값</p>

<ul>
  <li>곱 횟수 : $M(n)=3M(n/2)$ for $n&gt;1$, $M(1)=1$.
    <ul>
      <li>$M(n) = 3^{\log_2n}$</li>
    </ul>
  </li>
</ul>

<h3 id="closest-pair-problem">Closest-Pair Problem</h3>
<p><img src="/assets/img/%5BAL%5D6/cp1.png" width="30%" height="30%" />
<img src="/assets/img/%5BAL%5D6/cp2.png" width="60%" height="60%" /></p>

<ul>
  <li>Recurrence for the running time of the algorithm
    <ul>
      <li>$T(n) = 2T(n/2) + f(n) $, where $f(n)\in\Theta(n)$</li>
      <li>Applying the Master Theorem (with $a=2$, $b=2$, and $d=1$),  $T(n)\in\Theta(n\log n)$</li>
    </ul>
  </li>
</ul>

<h3 id="convex-hull">Convex-Hull</h3>
<ul>
  <li>Quickhull
    <ul>
      <li>$n$개의 점들 ($p_1(x_1, y_1), \cdots, p_n(x_n,y_n)$이 집합 $S$에 속해있다.</li>
      <li>$n$개의 점들을 $x$좌표를 기준으로 정렬한 뒤 양 끝점 $p_1$, $p_n$을 지나는 직선을 중심으로 위쪽을 $S_1$, 아래쪽을 $S_2$로 $S$를 두개의 평면으로 나눈다.</li>
    </ul>
  </li>
</ul>
<p align="center"><img src="/assets/img/%5BAL%5D6/ch1.png" width="60%" height="60%" /></p>

<h4 id="quickhull">Quickhull</h4>
<ul>
  <li>$S_1$이 비어있을 경우 두 점 $p_1$, $p_n$을 연결한 선분을 추가한다.</li>
  <li>$S_1$이 비어있지 않을 경우 집합 $S_1$의 점중 직선 $\overrightarrow{p_1p_n}$과의 거리가 가장 먼 점 $p_max$을 찾는다.</li>
  <li>$\overrightarrow{p_1p_{max}}$의 왼쪽에 있는 점들의 집합을 $S_{1,1}$, $\overrightarrow{p_{max}p_n}$의 왼쪽에 있는 점들의 집합을 $S_{1,2}$라고 하고 이 집합들에 대해 위의 과정을 반복한다.</li>
</ul>

<p align="center"><img src="/assets/img/%5BAL%5D6/qh.png" width="60%" height="60%" /></p>

<ul>
  <li>worst-case : $\Theta(n^2)$</li>
  <li>average-case : lnear</li>
</ul>]]></content><author><name>Junhwan</name></author><category term="ComputerScience" /><category term="algorithm" /><category term="CSE214" /><summary type="html"><![CDATA[Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin]]></summary></entry><entry><title type="html">[AL] 4. Brute Force and Exhaustive Search</title><link href="http://localhost:4000/computerscience/AL-4-Brute-Force-and-Exhaustive-Search-copy/" rel="alternate" type="text/html" title="[AL] 4. Brute Force and Exhaustive Search" /><published>2022-05-01T00:00:00+09:00</published><updated>2022-05-01T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/%5BAL%5D%204%20Brute%20Force%20and%20Exhaustive%20Search%20copy</id><content type="html" xml:base="http://localhost:4000/computerscience/AL-4-Brute-Force-and-Exhaustive-Search-copy/"><![CDATA[<blockquote>
  <p>Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin</p>
</blockquote>

<h1 id="brute-force">Brute Force</h1>
<p>문제를 해결하기 위한 간단한 접근 방식이며, 보통 문제의 문장과 관련된 개념의 정의에 직접적으로 기초한다.</p>

<p>영리하거나 효율적인 알고리즘의 소스가 되는 경우는 드물지만 Brute force는 중요한 알고리즘 디자인 전략으로써 간과해선 안된다.</p>
<ol>
  <li>매우 다양한 문제에 적용될 수 있다.</li>
  <li>어떤 중요한 문제에 대해 적어도 입력의 크기에 제한 없는 실제적인 값에 의미있는 알고리즘이 된다.
    <ul>
      <li>ex) sorting, searching, matrix multiplication, string matching</li>
    </ul>
  </li>
  <li>적은 수의 입력만 해결할 필요가 있고 허용할만한 속도로 해결할 수 있다면 더 효율적인 알고리즘을 만들기 위해 비용을 들이지 않아도 된다.</li>
  <li>일반적으로 매우 비효율적이더라도 작은 크기의 입력을 가진 문제를 푸는데 있어서 유용할 수 있다.</li>
  <li>더욱 효율적인 대안을 판단하는 기준으로 이론적, 교육적 목적을 제공한다.</li>
</ol>

<h2 id="sorting">Sorting</h2>

<h3 id="selection-sort">Selection sort</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM SelectionSort(A[0..n-1])
    //Input: An array A[0..n-1] of orderable elements
    //Output: Array A[0..n-1] sorted in nondecreasing order
    for i &lt;- 0 to n-2 do
        min &lt;- i
        for j &lt;- i+1 to n-1 do
            if A[j] &lt; A[min] min &lt;- j
        swap A[i] and A[min]
</code></pre></div></div>
<ul>
  <li>Input Size: The number of elements, n</li>
  <li>Basic operation: The key comparison
  \(C(n)=\sum^{n-2}_{i=0}\sum^{n-1}_{j=i+1}1==\sum^{n-2}_{i=0}(n-1-i)={(n-1)n\over 2}\)</li>
  <li>모든 입력에서 $\Theta(n^2)$</li>
  <li>key의 swap은 $n-1$번만 일어난다. 이것은 다른 정렬 알고리즘과 비교하였을 때 좋은 점이다.</li>
</ul>

<h3 id="bubble-sort">Bubble sort</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM BubbleSort(A[0..n-1])
    //Input: An array A[0..n-1] of orderable elements
    //Output: Array A[0..n-1] sorted in nondecreasing order
    for i &lt;- 0 to n-2 do
        for j &lt;- n-2-i to n-1 do
            if A[j+1] &lt; A[j] swap A[j] and A[j+1]
</code></pre></div></div>
<ul>
  <li>key comparison 횟수는 모든 입력에 대해 동일하나 swap 횟수는 입력에 따라 달라진다.</li>
  <li>worst case에서 swap 횟수와 comparison 횟수가 같다</li>
  <li>각 반복에서 교환이 한번도 일어나지 않았다면 알고리즘을 멈추는것으로 개선할 수 있다.</li>
</ul>

<h2 id="search">Search</h2>

<h3 id="sequential-search">Sequential Search</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM SequentialSearch2(A[0..n],K)
    //Input: An Array A of n elements and a search key K
    //Output: The index of the first element in A[0..n-1] whose value is equal to K or -1 if no such element is found
    A[n] &lt;- K
    i &lt;- 0
    while A[i] != K do
        i &lt;- i+1
    if i &lt; n return i
    else return -1 
</code></pre></div></div>
<ul>
  <li>배열이 정렬되어 있다면 요소가 search key보다 크거나 같아진다면 알고리즘을 멈추는 것으로 개선할 수 있다.</li>
</ul>

<h3 id="string-matching">String matching</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM BruteForceStringMatch(T[0..n-1], P[0..m-1])
    //Input: An array T[0..n-1] of n characters representing a text and
             An array P[0..m-1] of m characters representing a pattern
    //Output: The index of the first character in the text that starts a matching substring or -1 if the search is unsuccessful
    for i &lt;- 0 to n-m do
        j &lt;- 0
        while j &lt; m and P[j] = T[i+j] do
            j &lt;- j+1
        if j = m return i
    return -1    
</code></pre></div></div>
<ul>
  <li>최악의 경우 이 알고리즘은 $m(n-m+1)$개의 character를 비교해야하고 이것은 $O(nm)이다.</li>
  <li>그러나 일반적인 자연어 텍스트의 경우 대부분 매우 적은 비교 이후 <code class="language-plaintext highlighter-rouge">i</code>의 이동이 일어날 것으로 기대해야한다.</li>
  <li>랜덤 텍스트에서 검색할 경우 $\Theta(n)$로 보였다.</li>
</ul>

<h2 id="geometric-problems">Geometric problems</h2>

<h3 id="closest-pair-problem">Closest-Pair Problem</h3>
<p>점들의 집합에서 가장 가까운 두 점을 찾기.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALGORITHM BruteForceClosestPair(P)
    //Input: A list P of n (n&gt;=2) points p1(x1,y1),...,pn(xn,yn)
    //Output: The distance between the closest pair of points
    d &lt;- ∞
    for i &lt;- 1 to n-1 do
        for j &lt;- i+1 to n do
            d &lt;- min(d, sqrt((xi-xj)^2 + (yi-yj)^2))
    return d
</code></pre></div></div>
<ul>
  <li>Basic operation: computing the sqrt -&gt; squaring a number
  \(C(n)=\sum^{n-1}_{i=1}\sum^{n}_{j=i+1}2 = 2\sum^{n-1}_{i=1}(n-i)=n(n-1)\in\Theta(n^2)\)</li>
</ul>

<h3 id="convex-hull-problem">Convex-Hull Problem</h3>
<p>평면 또는 고차워너 공간의 특정 점 집합에서 볼록 껍질 찾기.</p>
<ul>
  <li>컴퓨터 기하학에서 가장 중요한 문제들 중 하나이다.</li>
  <li>볼록 껍질은 주어진 물체의 모양과 데이터 셋에 가까운 근사치를 제공한다.</li>
  <li>정의
    <ul>
      <li>공간상에서 점들의 집합(유한 or 무한)의 어느 두 점 $p$와 $q$에 대해 $p$와 $q$의 끝점을 연결한 선분들이 모두 집합에 속한다면 Convex한다고 한다.</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/%5BAL%5D4/convexhull.png" alt="convexhull" width="70%" height="70%" /></p>

<ul>
  <li>Algorithm
    <ul>
      <li>두 점 $(x_1,\ y_1),\ (x_2,\ y_2)$을 지나는 직선은 다음과 같이 정의된다
\(ax+by=c\)
\(a=y_2-y_1,\ b=x_1=x_2,\ c=x_1y_2-y_1x_2\)</li>
      <li>이 직선의 방정식은 평면을 $ax+by&gt;c$ 와 $ax+by&lt;c$ 두개의 평면으로 나눈다.</li>
      <li>모든 점들이 같은 평면에 있다면 그 직선을 선택한다.
        <ul>
          <li>$ax+by-c$의 부호를 확인하는 방법을 사용한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Time efficiency : $O(n^3)$</li>
</ul>

<h1 id="exhaustive-search">Exhaustive Search</h1>
<h2 id="combinational-problems">Combinational problems</h2>

<h3 id="tsp">TSP</h3>
<p>최소비용으로 모든 도시를 여행하는 방법을 찾는 문제
<img src="/assets/img/%5BAL%5D4/TSP.png" alt="TSP" width="70%" height="70%" /></p>
<ul>
  <li>The total number of permutations : ${1\over2}(n-1)!$</li>
</ul>

<h3 id="knapsack-problem">Knapsack problem</h3>
<p>weight $w_i$, value $v_i$를 가진 $n$개의 아이템의 부분집합 중 가방에 담을 수 있는 가장 비싼 집합을 찾는 문제
<img src="/assets/img/%5BAL%5D4/knapsack1.png" alt="knapack" width="50%" height="50%" /> 
<img src="/assets/img/%5BAL%5D4/knapsack2.png" alt="knapack" width="40%" height="40%" /></p>
<ul>
  <li>모든 부분집합을 만들고 가방에 담을 수 있는 부분 집합 중 가장 비싼 부분집합을 선택한다.</li>
  <li>The number of subsets of an n-element set is $2^n$
    <ul>
      <li>$\Omega(2^n)$ algorithm</li>
    </ul>
  </li>
</ul>

<h3 id="assigntment-problem">Assigntment problem</h3>
<p>$n$명의 사람에게 $n$개의 일을 한 사람 당 하나씩 최소 비용으로 부여하는 문제
<img src="/assets/img/%5BAL%5D4/assign.png" alt="assign" width="100%" height="100%" /></p>

<p><img src="/assets/img/%5BAL%5D4/assign2.png" alt="assign2" height="100%" /></p>
<ul>
  <li>가능한 모든 순열을 구한 뒤 각 순열마다 비용을 구해 최소값을 갖는 순열을 찾는다.</li>
</ul>]]></content><author><name>Junhwan</name></author><category term="ComputerScience" /><category term="algorithm" /><category term="CSE214" /><summary type="html"><![CDATA[Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin]]></summary></entry><entry><title type="html">[AL] 3. Fundamentals of the Analysis of Algorithm Efficiency</title><link href="http://localhost:4000/computerscience/AL-3-Fundamentals-of-the-Analysis-of-Algorithm-Efficiency/" rel="alternate" type="text/html" title="[AL] 3. Fundamentals of the Analysis of Algorithm Efficiency" /><published>2022-05-01T00:00:00+09:00</published><updated>2022-05-01T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/%5BAL%5D%203%20Fundamentals%20of%20the%20Analysis%20of%20Algorithm%20Efficiency</id><content type="html" xml:base="http://localhost:4000/computerscience/AL-3-Fundamentals-of-the-Analysis-of-Algorithm-Efficiency/"><![CDATA[<blockquote>
  <p>Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin</p>
</blockquote>

<h2 id="efficiency">Efficiency</h2>
<ul>
  <li>시간 효율성 (시간 복잡도) : 문제에서 알고리즘이 얼마나 빨리 실행되는지를 의미한다.</li>
  <li>공간 효율성 (공간 복잡도) : 입출력에 필요한 공간 외에 알고리즘에 필요한 메모리 단위의 양을 의미한다.
현재 일반적으로 알고리즘에 필요한 추가 공간의 양은 크게 중요하지 않다. 대부분의 문제에서 공간보다 속도에서 훨씬 더 눈부신 발전을 이룰 수 있다.</li>
</ul>

<h2 id="time-efficiency">Time efficiency</h2>

<h3 id="measuring-an-algorithms-running-time">Measuring an algorithm’s running time</h3>
<ul>
  <li>프로그램의 실행시간 측정
    <ul>
      <li>특정 컴퓨터의 속도에 의존</li>
      <li>알고리즘을 구현하는 프로그램의 성능과 기계 코드를 생성하는 데 사용되는 컴파일러의 성능에 의존된다.</li>
      <li>프로그램의 실제 실행 시간을 측정하는 것은 어렵다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">basic operation</code>이 실행되는 횟수를 세는 방법
    <ul>
      <li>알고리즘의 <code class="language-plaintext highlighter-rouge">basic operation</code>을 확인하고 이것이 실행되는 횟수를 계산한다.</li>
      <li><code class="language-plaintext highlighter-rouge">Basic operation</code> : 총 실행 시간에 가장 많이 기여하는 작업 (일반적으로 일고리즘의 가장 안쪽 루프에서 가장 시간이 많이 걸리는 작업)
        <ul>
          <li>Example
            <ul>
              <li>정렬 알고리즘에서의 <code class="language-plaintext highlighter-rouge">key comparision</code></li>
              <li>수학적 문제에서의 사칙연산</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="tn">$T(n)$</h3>

<p>$n$ : input size, $T(n)$ : running time,  $c_{op}$ : execution time for basic operation, $C(n)$ : Number of times basic operation is executed
\(T(n) \approx c_{op}C(n)\)</p>

<h3 id="efficiency-on-particular-input">Efficiency on particular input</h3>
<ul>
  <li>특정 입력에 따라 효율성이 달라지는 알고리즘이 있다.
    <ul>
      <li>Sequencial search</li>
    </ul>
  </li>
  <li>The worst-case efficiency $C_{worst}(n)$
    <ul>
      <li>크기가 <code class="language-plaintext highlighter-rouge">n</code>인 모든 입력 중 가장 느리게 실행회는 worst-case의 efficiency.</li>
      <li>크기가 <code class="language-plaintext highlighter-rouge">n</code>인 입력에 대해 실행시간이 $C_{worst}(n)$를 초과하지 않음을 보장한다.</li>
    </ul>
  </li>
  <li>The best-case efficiency $C_{best}(n)$
    <ul>
      <li>크기가 <code class="language-plaintext highlighter-rouge">n</code>인 모든 입력 중 가장 빠르게 실행되는 best-case의 efficiency.</li>
      <li>best-case efficiency에 대한 분석은 worst-case efficiency에 대한 분석만큼 중요하진 않지만 완전히 쓸모 없는 것은 아니다.</li>
    </ul>
  </li>
  <li>The average-case efficiency $C_{avg}(n)$
    <ul>
      <li>average-case efficiency는 best-case 및 worst-case의 efficiency 조사보다 상당히 어렵다.</li>
    </ul>
  </li>
</ul>

<h4 id="sequencial-search">Sequencial search</h4>
<p>Pseudo code</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algorithm SequentialSearch(A[0..n-1], K)
    i &lt;- 0
        while i&lt;n and A[i]!=K do
            i &lt;- i+1
    if i &lt; n return i
    else return -1

</code></pre></div></div>

<ul>
  <li>$C_{worst}(n) = n$</li>
  <li>$C_{best}(n) = 1$</li>
  <li>$C_{avg}(n)$
    <ul>
      <li>$\sum_{i=1}^{n}({p \over n}i)+n(1-p) =  {p(n+1) \over 2}+n(1-p)$</li>
      <li>if $p=1$, $C_{avg}(n) = {n+1 \over 2}$</li>
      <li>if $p=0$, $C_{avg}(n) = n$</li>
    </ul>
  </li>
</ul>

<h3 id="asymptotic-order-of-growth">Asymptotic order of growth</h3>
<h4 id="ogn">$O(g(n))$</h4>
<p>$g(n)$보다 작거나 같은 증가율 가진 함수들의 집합
<img src="/assets/img/%5BAL%5D3/BigO.png" alt="bigO" width="70%" height="70%" /></p>

\[t(n) \in O(g(n))\]

\[^\exists c&gt;0 \quad s.t. \quad t(n) \le cg(n) \ for \ all \ n \ge n_0\]

<h4 id="omegagn">$\Omega(g(n))$</h4>
<p>$g(n)$보다 크거나 같은 증가율 합수들의 집합</p>

<p><img src="/assets/img/%5BAL%5D3/BigOmega.png" alt="bigOmega" width="70%" height="70%" /></p>

\[t(n) \in \Omega(g(n))\]

\[^\exists c &gt;0 \quad s.t. \quad t(n) \ge cg(n) \quad for \ \  all \ \  n \ge n_0\]

<h4 id="thetagn">$\Theta(g(n))$</h4>
<p><img src="/assets/img/%5BAL%5D3/BigTheta.png" alt="bigTheta" width="70%" height="70%" /></p>

<p>$g(n)$과 같은 증가율을 가진 함수들의 집합</p>

\[t(n) \in \Theta(g(n))\]

\[^\exists c_1, \ c_2&gt;0 \quad s.t. \quad  c_1g(n) \le t(n) \le c_2g(n) \quad for \ \  all \ \  n \ge n_0\]

<h4 id="using-limits-for-comparing-orders-of-grouth">Using limits for comparing orders of grouth</h4>

\[\lim_{n\rightarrow \infty}=\begin{cases}0\quad implies\ that\ t(n)\ has \ a\ smaller\ order\ of\ growth\ than\ g(n)\\c \quad implies\ that\ t(n)\ has \ the\ same\ order\ of\ growth\ as\ g(n) \\\infty \quad implies\ that\ t(n)\ has \ a\ larger\ order\ of\ growth\ as\ g(n) \end{cases}\]

<ul>
  <li>첫번째 두 경우는 $t(n) \in O(g(n))$을 의미한다</li>
  <li>마지막 두 경우는  $t(n) \in \Omega(g(n))$을 의미한다</li>
  <li>두번째 경우는  $t(n) \in \Theta(g(n))$을 의미한다</li>
</ul>

<h3 id="nonrecursive-algorithms">Nonrecursive algorithms</h3>

<h4 id="example-1-maximum-element">Example 1: Maximum element</h4>
<ul>
  <li>Pseudo code
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ALGORITHM MaxElement(A[0...n-1])
      maxval &lt;- A[0]
      for i &lt;- 1 to n-1 do
          maxval &lt;- A[i]
      return maxval
</code></pre></div>    </div>
  </li>
  <li>Input size : the numver of elements in the array, n</li>
  <li>Basic operation : comparison</li>
  <li>
\[C(n) = \sum^{n-1}_{i=1}1=n-1\in\Theta(n)\]
  </li>
</ul>

<h4 id="example-2-element-uniqueness-problem">Example 2: Element uniqueness problem</h4>
<ul>
  <li>Pseudo code
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ALGORITHM UniqueElements(A[0...n-1])
      for i &lt;- 0 to n-2 do
          for j &lt;- i+1 to n-1 do
              if A[i] = A[j] return false
      return true
</code></pre></div>    </div>
  </li>
  <li>Input size : the numver of elements in the array, n</li>
  <li>Basic operation : comparison</li>
  <li>The worst cases:
    <ul>
      <li>배열에 같은 원소가 없는 경우</li>
      <li>마지막 두 원소가 같은 경우
\(C_{worst}(n) = \sum^{n-2}_{i=0}\sum_{j=i+1}^{n-1}1=\sum^{n-2}_{i=0}(n-i-1)={n(n-1)\over2}\approx{1\over2}n^2\in\Theta(n^2)\)</li>
    </ul>
  </li>
</ul>

<h4 id="example-3-matrix-multiplication">Example 3: Matrix multiplication</h4>
<p align="center">
	<img src="/assets/img/%5BAL%5D3/matrix.png" alt="kingdom" width="70%" height="70%" />
</p>
<ul>
  <li>Pseudo code
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ALGORITHM MatrixMultiblication(A[0...n-1])
      for i &lt;- 0 to n-1 do
          for j &lt;- 0 to n-1 do
              C[i,j] &lt;- 0.0
              for k &lt;- 0 to n-1 do
                  C[i,j] &lt;- C[i,j] + A[i,k]*B[k,j]
      return C
</code></pre></div>    </div>
  </li>
  <li>Input size : the numver of elements in the array, n</li>
  <li>Basic operation : multiplication and addition</li>
</ul>

<center>$$M(n) = \sum^{n-1}_{i=0}\sum^{n-1}_{j=0}\sum^{n-1}_{k=0}= \sum^{n-1}_{i=0}\sum^{n-1}_{j=0}n=\sum^{n-1}_{i=0}n^2=n^3$$
$$T(n) \approx c_mM(n)+c_aM(n)=(c_m+c_a)n^3$$</center>

<h4 id="example-4-counting-binary-digits">Example 4: Counting binary digits</h4>
<ul>
  <li>Pseudo code
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ALGORITHM Binary(n)
      count &lt;- 1
      while n&gt;1 do
          count &lt;- count+1
          n &lt;- ⌊n/2⌋
      return count
</code></pre></div>    </div>
  </li>
  <li>Basic operation : comparison</li>
  <li>The total number of comparison : $\lfloor \log_2n\rfloor+1$</li>
</ul>

<h3 id="recursive-algorithms">Recursive algorithms</h3>

<h4 id="example-1-maximum-element-1">Example 1: Maximum element</h4>
<ul>
  <li>Pseudo code
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ALGORITHM F(n)
      if n=0 return 1
      else return F(n-1) * n
</code></pre></div>    </div>
  </li>
  <li>Input size : n</li>
  <li>Basic operation : multiplication
\(M(n) = M(n-1) + 1 \quad  for \quad n&gt;0,\quad M(0) =0\)
\(M(n) = M(n-1) + 1 =\ \cdots\ = M(n-n)+n=n\)</li>
</ul>

<h4 id="example-2-tower-of-hanoi-puzzle">Example 2: Tower of Hanoi puzzle</h4>
<p><img src="/assets/img/%5BAL%5D3/hanoi.png" alt="hanoi" width="70%" height="70%" /></p>
<ul>
  <li>Input size : the number of disks, n</li>
  <li>Basic operation : moving one disk</li>
</ul>

<p>\(M(n) = 2M(n-1) + 1 \quad  for \quad n&gt;1, \quad M(1)=1\)
\(M(n) = 2M(n-1) + 1 = 2[2M(n-2) + 1]+1 =\ \cdots\ = 2^{n-1}M(n-(n-1))+2^{n-1}-1=2^n-1\)</p>

<h4 id="example-3-counting-binary-digits-recursion">Example 3: Counting binary digits (recursion)</h4>
<ul>
  <li>Pseudo code
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ALGORITHM BinRec(n)
      if n=1 return 1
      else return BinRec(⌊n/2⌋)+1
</code></pre></div>    </div>
  </li>
  <li>The total number of additions : $A(n)$</li>
  <li>Recurrence : $A(n) = A(\lfloor {n\over2} \rfloor ) + 1$ for $n&gt;1$</li>
  <li>Initial condition: $A(1)=0$</li>
  <li>Smoothness rule</li>
</ul>

\[n=2^k\quad\quad\]

\[A(2^k)=A(2^{k-1})+1\quad for\quad k&gt;0,\quad A(2^0)=0\]

\[A(2^k) = A(2^{k-k})+k = A(1) + k = k\]

\[n=2^k,\quad k=\log_2n\]

\[A(n) = \log_2n\in\Theta(\log n)\]

<h4 id="example-4-computing-the-nth-fibonacci-number">Example 4: Computing the nth Fibonacci number</h4>
<ul>
  <li>Pseudo code
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ALGORITHM F(n)
      if n&lt;=1 return n
      else return F(n-1) + F(n-2)
</code></pre></div>    </div>
  </li>
  <li>Basic operation : addition</li>
  <li>The total number of additions : $A(n)$
    <ul>
      <li>
        <p>$A(2^k)=A(n-1)+A(n-2)+1\quad for\quad n&gt;1$</p>

        <p>$A(0)=0,\quad A(1)=0$</p>

        <p>$A(n) - A(n-1)-A(n-2)=1$</p>

        <p>$[A(n)+1]-[A(n-1)+1]-[A(n-2)+1]=0$</p>

        <p>$B(n) = A(n)+1$</p>

        <p>$B(n) - B(n-1)-B(n-2)=0,\quad B(0)=1,\quad B(1)=1$</p>

        <p>$B(n)={1\over \sqrt5}(\phi ^{n+1} - \hat\phi^{n+1} )$</p>

        <p>$A(n)={1\over \sqrt5}(\phi ^{n+1} - \hat\phi^{n+1} )-1 \in\Theta(\phi^n)$</p>
      </li>
    </ul>
  </li>
  <li>$\Theta(\log n)$ algorithm
    <ul>
      <li>\(\left[\begin{matrix}F(n-1) &amp; F(n) \\ F(n) &amp; F(n+1)\end{matrix}\right] = \left[ \begin{matrix}0&amp;1\\1&amp;1\end{matrix}\right]^n\)
for $n\ge1$</li>
    </ul>
  </li>
</ul>]]></content><author><name>Junhwan</name></author><category term="ComputerScience" /><category term="algorithm" /><category term="CSE214" /><summary type="html"><![CDATA[Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin]]></summary></entry><entry><title type="html">[AL] 2. Important problem types</title><link href="http://localhost:4000/computerscience/AL-2-Important-problem-types/" rel="alternate" type="text/html" title="[AL] 2. Important problem types" /><published>2022-04-30T00:00:00+09:00</published><updated>2022-04-30T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/%5BAL%5D%202%20Important%20problem%20types</id><content type="html" xml:base="http://localhost:4000/computerscience/AL-2-Important-problem-types/"><![CDATA[<blockquote>
  <p>Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin</p>
</blockquote>

<h2 id="sorting">Sorting</h2>
<h3 id="sorting을--하는-이유">Sorting을  하는 이유</h3>
<ul>
  <li>정렬이 출력으로 요구되는 작업이 있다.
    <ul>
      <li>ex) ranking</li>
    </ul>
  </li>
  <li>정렬은 리스트에 대한 질문에 쉽게 대답할 수 있게 해준다
    <ul>
      <li>ex) searching</li>
    </ul>
  </li>
  <li>정렬은 다른 분야의 중요한 알고리즘의 보조 단계로 사용된다.
    <ul>
      <li>ex) geometric algorithms and data compression</li>
    </ul>
  </li>
</ul>

<h3 id="sorting-알고리즘의-예">Sorting 알고리즘의 예</h3>
<ul>
  <li>Selection sort</li>
  <li>Bubble sort</li>
  <li>Insertion sort</li>
  <li>Merge sort</li>
  <li>Heap sort</li>
  <li>…
Sorting 알고리즘의 복잡성은 key의 비교 횟수로 평가한다.</li>
</ul>

<h3 id="sorting-알고리즘의-속성">Sorting 알고리즘의 속성</h3>
<p><code class="language-plaintext highlighter-rouge">stable</code> : 입력에서의 동일한 두 요소의 상대적인 순서가 바뀌지 않는 경우
<code class="language-plaintext highlighter-rouge">in place</code> : 적은 메모리 단위를 제외한 추가 메모리를 사용하지 않는 경우</p>

<h3 id="selection-sort">Selection Sort</h3>
<p>Input : array <code class="language-plaintext highlighter-rouge">a[1]</code>,…,<code class="language-plaintext highlighter-rouge">a[n]</code></p>

<p>Output :  array a sorted in non-decreasing order</p>

<p>Algorithm:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i=1 to n 
    swap a[i] with smallest of a[i],…,a[n] 
</code></pre></div></div>
<p>Pseudocode</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algorithm SelectionSort(A[0..n-1])
//The algorithm sorts a given array by selection sort
//Input: An array A[0..n-1] of orderable elements
//Output: Array A[0..n-1] sorted in ascending order
for i  0 to n – 2 do
	min  i
	for j  i + 1 to n – 1 do
		if A[j] &lt; A[min] 	
			min  j
	swap A[i] and A[min]
</code></pre></div></div>

<h2 id="searching">Searching</h2>
<ul>
  <li>
    <p>주어진 집합(또는 여러 요소가 동일한 값을 가질 수 있도록 허용된 다중 집합)에서 주어진 <code class="language-plaintext highlighter-rouge">search key</code>를 찾는다.</p>
  </li>
  <li>
    <p>Example</p>
    <ul>
      <li>Sequentail search</li>
      <li>Binary search</li>
    </ul>
  </li>
</ul>

<h2 id="string-processing">String processing</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">string</code>: character 배열</li>
  <li><code class="language-plaintext highlighter-rouge">Text strings</code>: letters, numbers, and special characters.</li>
  <li><code class="language-plaintext highlighter-rouge">String matching</code>: 글에서 주어진 단어나 패턴을 검색</li>
</ul>

<h2 id="graph-problems">Graph problems</h2>
<ul>
  <li>실제 문제 모델링
    <ul>
      <li>World Wide Web(WWW) 모델링</li>
      <li>통신망 모델링</li>
      <li>프로젝트 스케줄링</li>
    </ul>
  </li>
  <li>기본적인 그래프 알고리즘
    <ul>
      <li>그래프 순회 알고리즘</li>
      <li>최단거리 알고리즘</li>
      <li>위상정렬</li>
    </ul>
  </li>
</ul>

<h2 id="combinational-problems">Combinational problems</h2>
<ul>
  <li>명시적으로나 암묵적으로 순열, 조합, 부분집합과 같은 <code class="language-plaintext highlighter-rouge">combinatorial object</code>를 찾는것을 요청</li>
  <li>ex) traveling salesman problem (TSP)
    <ul>
      <li>N개 도시를 모두 정확히 한 번 방문하는 최단 기간 찾기</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Combinational</code> 문제는 이론적 및 실제적 관점에서 컴퓨팅에서 가장 어려운 문제이다.</li>
  <li><code class="language-plaintext highlighter-rouge">combinatorial object</code>의 수는 일반적으로 문제의 크기에 따라 매우 빠르게 증가한다.</li>
  <li>제한된 시간안에 정확하게 푸는 알려진 알고리즘이 없다.</li>
</ul>

<h2 id="geometric-problems">Geometric problems</h2>
<ul>
  <li>점, 선, 다각형과 같은 <code class="language-plaintext highlighter-rouge">geometric object</code>를 다룬다.
    <ul>
      <li>응용 : 컴퓨터 그래픽, 로보틱스, 단층 촬영</li>
    </ul>
  </li>
  <li>Example
    <ul>
      <li>The closest-pair problem</li>
      <li>The convex-hull problem</li>
    </ul>
  </li>
</ul>

<h2 id="numerical-problems">Numerical problems</h2>
<ul>
  <li>연속적인 <code class="language-plaintext highlighter-rouge">mathematical objects</code>를 포함하는 문제이다.</li>
  <li>이러한 대부분의 수학적 문제들은 근사적으로만 풀 수 있다.</li>
  <li>근사된 숫자에 대해 산술 연산을 많이 수행하면 반올림 오차가 누적되어 크게 왜곡될 수 있다.</li>
  <li>Example
    <ul>
      <li>방정식</li>
      <li>연립방적식</li>
      <li>정적분</li>
      <li>함수값 계산</li>
    </ul>
  </li>
</ul>]]></content><author><name>Junhwan</name></author><category term="ComputerScience" /><category term="algorithm" /><category term="CSE214" /><summary type="html"><![CDATA[Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin]]></summary></entry><entry><title type="html">[AL] 1. Intro</title><link href="http://localhost:4000/computerscience/AL-1.-Intro/" rel="alternate" type="text/html" title="[AL] 1. Intro" /><published>2022-04-30T00:00:00+09:00</published><updated>2022-04-30T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/%5BAL%5D%201.%20Intro</id><content type="html" xml:base="http://localhost:4000/computerscience/AL-1.-Intro/"><![CDATA[<blockquote>
  <p>Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin</p>
</blockquote>

<h2 id="algorithm을-공부해야하는-이유">Algorithm을 공부해야하는 이유</h2>

<h3 id="컴퓨터-전문가가-되려고-하는-학생이라면">컴퓨터 전문가가 되려고 하는 학생이라면</h3>
<ul>
  <li>실용적인 이유
    <ul>
      <li>다양한 컴퓨팅 분야의 중요한 Algorithm의 표준적인 집합을 알아야한다.</li>
      <li>새로운 Algorithm을 디자인하고 효율성을 분석할 수 있어야 한다.</li>
    </ul>
  </li>
  <li>이론적인 이유
    <ul>
      <li>algorithmics은 컴퓨터 과학의 기반이다.</li>
    </ul>
  </li>
</ul>

<h3 id="computing-related-학생이-아니라면">computing-related 학생이 아니라면</h3>
<ul>
  <li>Algorithm이 없는 컴퓨터 프로그램은 존재하지 않는다.</li>
  <li>컴퓨터 어플리케이션이 우리의 직업적, 개인적인 삶의 거의 모든 면에서 필수불가결해지면서, Algorithm을 공부하는 것은 점점 더 많은 사람들에게 필수가 됨</li>
</ul>

<p><strong>Algorithm을 공부하는 것은 분석 기술을 기르는데 유용하다.</strong></p>

<h2 id="what-is-an-algorithm">What is an algorithm</h2>

<p>An algorithm is a sequence of unambiguous instructions for solving a problem, i.e., for obtaining a required output for any legitimate input in a finite amount of time.</p>

<p>Algorithm은 문제를 해결하기 위한 명확한 명령의 연속이다. 즉, 제한된 시간 내에 모든 허용된 입력에 필요한 출력을 얻기 위한 것이다.</p>

<h2 id="algorithm의-특징">Algorithm의 특징</h2>
<p>The nonambiguity requirement for each step of an algorithm cannot be compromised.</p>

<p>각 단계는 애매하지 않아야한다.</p>

<p>The range of inputs for which an algorithm works has to be specified carefully.</p>

<p>Algorithm이 작동하는 입력의 범위가 구체적으로 명시 되어야한다.</p>

<p>The same algorithm can be represented in several different ways.</p>

<p>같은 Algorithm은 여러 방법으로 표현될 수 있다.</p>

<p>There may exist several algorithms for solving the same problem.</p>

<p>같은 문제를 푸는 Algorithm은 다양하게 존재할 수 있다.</p>

<p>Algorithms for the same problem can be based on very different ideas and can solve the problem with dramatically different speeds.</p>

<p>같은 문제의 Algorithm은 매우 다른 아이디어에 기반될 수 있고 문제를 푸는 속도가 많이 차이날 수 있다.</p>

<h2 id="algorithm의-성질">Algorithm의 성질</h2>
<ul>
  <li>Finiteness
    <ul>
      <li>terminates after a finite number of steps</li>
      <li>유한한 개수의 명령 후에 끝이 나야한다.</li>
    </ul>
  </li>
  <li>Definiteness
    <ul>
      <li>rigorously and unambiguously specified</li>
      <li>엄격해야하고 중의적이지 않아야한다.</li>
    </ul>
  </li>
  <li>Clearly specified input
    <ul>
      <li>valid inputs are clearly specified</li>
      <li>입력이 명확하게 명시되어야한다.</li>
    </ul>
  </li>
  <li>Clearly specified/expected output
    <ul>
      <li>can be proved to produce the correct output given a valid input</li>
      <li>유효한 입력이 주어졌을 때 정확한 출력을 만들어 냈는지 증명할 수 있어야한다.</li>
    </ul>
  </li>
  <li>Effectiveness
    <ul>
      <li>steps are sufficiently simple and basic</li>
      <li>각 단계가 충분히 간단하고 기본적이어야한다.</li>
    </ul>
  </li>
</ul>

<h2 id="최대공약수-구하기">최대공약수 구하기</h2>
<h3 id="유클리드-algorithm">유클리드 Algorithm</h3>

<p><strong>Eclid’s algorithm</strong> for computing `gcd(m,n)</p>

<p><strong>Step 1</strong> 만약 <code class="language-plaintext highlighter-rouge">n=0</code> 이면 정답으로 <code class="language-plaintext highlighter-rouge">m</code>을 리턴하고 멈춘다.; 아니라면 <strong>Step 2</strong>를 진행한다.</p>

<p><strong>Step 2</strong> <code class="language-plaintext highlighter-rouge">m</code>을 <code class="language-plaintext highlighter-rouge">n</code>으로 나눈 나머지를 <code class="language-plaintext highlighter-rouge">r</code>에 할당한다.</p>

<p><strong>Step 3</strong> <code class="language-plaintext highlighter-rouge">n</code>을 <code class="language-plaintext highlighter-rouge">m</code>에 할당하고 <code class="language-plaintext highlighter-rouge">r</code>을 <code class="language-plaintext highlighter-rouge">n</code>에 할당한 뒤 <strong>Step 1</strong>로 돌아간다.</p>

<p>pseudo code</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//Inputs: Two nonegative, not-both-zero integers m and n
//OUtput: Greatest common divisor of m and n
Euclid(m,n)
  while n!=0 do
    r = m mod n
    m = n
    n = r
  return m
</code></pre></div></div>

<h3 id="consecutive-integer-checking-algorithm">Consecutive integer checking algorithm</h3>
<p><strong>Step 1</strong> <code class="language-plaintext highlighter-rouge">t</code>에 <code class="language-plaintext highlighter-rouge">min(m.n)</code>을 할당한다</p>

<p><strong>Step 2</strong> <code class="language-plaintext highlighter-rouge">m</code>을 <code class="language-plaintext highlighter-rouge">t</code>로 나누고 나머지가 <code class="language-plaintext highlighter-rouge">0</code>이라면 <strong>Step 3</strong>로 가고 아니면 <strong>Step 4</strong>로 간다.</p>

<p><strong>Step 3</strong> <code class="language-plaintext highlighter-rouge">n</code>을 <code class="language-plaintext highlighter-rouge">t</code>로 나누고 나머지가 <code class="language-plaintext highlighter-rouge">0</code>이라면 <code class="language-plaintext highlighter-rouge">t</code>를 정답으로 리턴하고 멈춘다. 아니라면 <strong>Step 4</strong>로 간다.</p>

<p><strong>Step 4</strong> <code class="language-plaintext highlighter-rouge">t</code>를 1 감소시키고 <strong>Step 2</strong>로 간다.</p>

<p>이 Algorithm은 입력값이 0일 때 제대로 작동하지 않는다.</p>

<h3 id="소인수-분해">소인수 분해</h3>
<p><strong>Step 1</strong> <code class="language-plaintext highlighter-rouge">m</code>을 소인수를 찾아라</p>

<p><strong>Step 2</strong> <code class="language-plaintext highlighter-rouge">n</code>을 소인수를 찾아라</p>

<p><strong>Step 3</strong> <strong>Step 1</strong>과 <strong>Step 2</strong>에서 공통으로 나오는 소인수를 찾아라</p>

<p><strong>Step 4</strong> 모두 곱해라</p>

<p>소인수 분해를 하는 방법이 unambiguously하게 정의되어 있지 않아 좋은 Algorithm 기술방법이 아니다.</p>

<h3 id="understanding-the-problem">Understanding the problem</h3>
<ul>
  <li>Algorithm을 디자인하기 전 첫번째로 해야하는 것은 주어진 문제를 충분히 이해하는 것이다.
    <ul>
      <li>문제 설명을 조심스럽게 읽는다.</li>
      <li>문제에 대해 조금이라도 의문이 있다면 질문한다.</li>
      <li>손으로 몇가지 작은 예시들을 풀어본다</li>
      <li>특이 케이스를 생각해본다.</li>
      <li>필요하다면 다시 질문해본다.</li>
    </ul>
  </li>
  <li>컴퓨터 응용프로그램에서 자주 발생하는 몇가지 문제들이 있다.
    <ul>
      <li>이런 문제라면 이미 알려진 Algorithm을 사용한다.</li>
      <li>사용 가능한 Algorithm을 찾지 못하면 직접 디자인한다.</li>
    </ul>
  </li>
  <li>
    <p>정확한 Algorithm은 대부분 잘 작동하는 것이 아닌 허용된 모든 입력에 대해 제대로 작동해야한다.
이 단계를 건너 뛴다면 불필요한 작업을 다시해야할 위험이 있다.</p>
  </li>
  <li>디바이스의 능력을 확인해야한다.
    <ul>
      <li>많은 상황에서 작업이 느려지는 것에 대해 걱정하지 않아도 된다.</li>
      <li>하지만 복잡한 문제이거나 거대한 양의 데이터를 작업해야하거나 시간이 큰 영향을 미치는 상황에선 이것은 중요한 문제이다.</li>
    </ul>
  </li>
</ul>

<h3 id="choosing-between-exact-and-approximate-problem-solving">Choosing between Exact and Approximate Problem Solving</h3>
<p>Approximation algorithm을 선택하는 경우</p>
<ol>
  <li>대부분의 경우에서 정확하게 해결할 수 없는 중요한 문제들이 있다.
Ex) 제곱근 구하기, 비선형 방정식 해결 및 유한 적분 계산</li>
  <li>문제를 정확하게 해결하기 위해 사용할 수 있는 Algorithm은 문제의 본질적인 복잡성 때문에 굉장히 느릴 수 있다.
    <ul>
      <li>이것은 특히, 매우 많은 수의 선택과 관련된 많은 문제들에서 발생한다.</li>
    </ul>
  </li>
  <li>근사 Algorithm은 문제를 정확하게 해결하는 Algorithm보다 정교한 Algorithm의 일부가 될 수 있다.</li>
</ol>

<h3 id="algorithm-설계-전략">Algorithm 설계 전략</h3>
<p>Algorithm 디자인 기술(전략)은 문제를 다양한 컴퓨팅 분야의 다양한 문제에 적용할 수 있는 Algorithm 방식으로 해결하기 위한 일반적인 접근이다.</p>

<h3 id="algorithm과-자료-구조-디자인">Algorithm과 자료 구조 디자인</h3>
<p>Algorithm 디자인 기술은 Algorithm 문제 해결에 대한 강력한 일반 접근 방식을 제공하지만,</p>
<ul>
  <li>특정 문제에 대한 Algorithm을 디자인하는 것은 여전히 ​​어려운 작업일 수 있다.</li>
  <li>일부 디자인 기술은 해당 문제에 단순히 적용할 수 없다.</li>
  <li>때로는 여러 기술을 결합해야 하며 알려진 디자인 기술의 적용으로 정확히 지적하기 어려운 Algorithm이 있다.</li>
</ul>

<p>Algorithm이 수행하는 작업에 적합한 데이터 구조를 선택하는 데 세심한 주의를 기울여야 한다.</p>
<ul>
  <li>Algorithm + 데이터 구조 = 프로그램 [Wir76]</li>
</ul>

<h3 id="algorithm을-표현하는-방법">Algorithm을 표현하는 방법</h3>
<ul>
  <li>natural language (자연어)</li>
  <li>Pesudocode
    <ul>
      <li>자연어와 프로그래밍 언어를 섞은 형태</li>
    </ul>
  </li>
  <li>Flowchart
    <ul>
      <li>복잡한 Algorithm엔 사용하기 어려워 잘 쓰이지 않는다.</li>
    </ul>
  </li>
</ul>

<h3 id="algorithm-correctness-증명">Algorithm Correctness 증명</h3>
<p>모든 허용된 입력에 대하여 제한된 시간안에 필요한 결과를 얻을 수 있는지 증명해야한다.
이 증명은 쉬운 경우도 있고 복잡한 경우도 있다.</p>

<h3 id="algorithm-분석">Algorithm 분석</h3>
<ul>
  <li>Efficiency
    <ul>
      <li>time : 얼마나 빠른지</li>
      <li>space : 메모리를 얼마나 사용하는지</li>
    </ul>
  </li>
  <li>Simplicity
    <ul>
      <li>더욱 간단한 Algorithm은 프로그램하기와 이해하기가 쉽고 가끔 더 효율적이다.</li>
    </ul>
  </li>
  <li>Generality
위의 것들을 만족하지 않으면 다시 디자인해야한다.</li>
</ul>

<h3 id="coding-an-algorithm">Coding an Algorithm</h3>
<p>대부분의 알고리즘의 궁극적인 목적은 컴퓨터 프로그램으로 구현되는 것이다.
알고리즘에서 프로그램으로 잘못 또는 매우 비효율적으로 변환될 위험성이 있다.
실질적인 문제로서, 프로그램의 유효성은 여전히 테스트를 통해 확립된다.
알고리즘을 구현할 때마다 프로그램을 철저히 테스트하고 디버깅해야한다.</p>

<p>일반적으로, 좋은 알고리즘은 반복적인 노력과 재작업의 결과이다.</p>]]></content><author><name>Junhwan</name></author><category term="ComputerScience" /><category term="algorithm" /><category term="CSE214" /><summary type="html"><![CDATA[Materials are adapted from “Introduction to the design &amp; Analysis of Algorithms,” 3rd ed., by A. Levitin]]></summary></entry><entry><title type="html">[AI] Uniformed Search</title><link href="http://localhost:4000/computerscience/1-Uniformed-Search/" rel="alternate" type="text/html" title="[AI] Uniformed Search" /><published>2022-04-24T00:00:00+09:00</published><updated>2022-04-24T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/1%20Uniformed%20Search</id><content type="html" xml:base="http://localhost:4000/computerscience/1-Uniformed-Search/"><![CDATA[<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>용어 정리
strategy : 전략
complete : solution이 하나 존재 할 때 그 solution을 찾는 것이 보장되어 있는가?
optimal : 최단 경로(the least cost path)를 찾는 것이 보장되어 있는가?   
</code></pre></div></div>

<h1 id="uniformed-search">Uniformed Search</h1>
<h2 id="agents">Agents</h2>
<h3 id="rational-agents">Rational agents</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Rational agent</code>는 명확한 선호도를 가지고 기대치를 통해 불확실성을 모델링하고, 모든 실행 가능한 행동 중 항상 자신에게 최적의 결과를 가져오도록 행동을 수행하도록 선택하는 agent이다.
    <h3 id="reflex-agents">Reflex agents</h3>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Reflex agent</code>s는 현재 상태에 기반을 두어 다음 <code class="language-plaintext highlighter-rouge">action</code>을 선택하는 <code class="language-plaintext highlighter-rouge">agent</code>로 이 Action이 가져올 미래에 대해 고려하지 않는다.</li>
</ul>

<h3 id="planning-agents">Planning agents</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Planning agents</code>는 (가설화된) <code class="language-plaintext highlighter-rouge">sequences of action</code>에 기반을 두어 결정한다.</li>
  <li><code class="language-plaintext highlighter-rouge">World</code>가 <code class="language-plaintext highlighter-rouge">action</code>에 대응하여 어떻게 변해가는지에 대한 모델을 가지고 있다.</li>
</ul>

<h2 id="search">Search</h2>
<h3 id="search-problem">Search Problem</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Search Problem</code>은 <code class="language-plaintext highlighter-rouge">state space</code>(상태 공간), <code class="language-plaintext highlighter-rouge">successor function</code>(후계 함수 action, cost 포함), <code class="language-plaintext highlighter-rouge">start state</code> (시작 상태) 및 <code class="language-plaintext highlighter-rouge">goal test</code>로 구성된다.</li>
  <li>솔루션은 <code class="language-plaintext highlighter-rouge">start state</code>(시작 상태)를 <code class="language-plaintext highlighter-rouge">goal state</code>(목표 상태)로 변환하는 <code class="language-plaintext highlighter-rouge">sequenc of action</code>(plan)이다.</li>
</ul>

<h3 id="state-space-graph">State Space Graph</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">State space graph</code>는 <code class="language-plaintext highlighter-rouge">search problem</code>의 수학적 표현이다. <code class="language-plaintext highlighter-rouge">Node</code>들은 <code class="language-plaintext highlighter-rouge">state</code>를, <code class="language-plaintext highlighter-rouge">arcs</code>는 <code class="language-plaintext highlighter-rouge">action</code>을 나타내며 이것이 가르키는 <code class="language-plaintext highlighter-rouge">node</code>는 그 <code class="language-plaintext highlighter-rouge">action</code>의 결과이다.</li>
  <li>Search graph에서 각 state는 한 번씩 등장한다.</li>
  <li>전체 그래프는 매우 크기 때문에 메모리에 거의 만들 수 없지만 유용한 아이디어이다.</li>
</ul>

<h3 id="search-tree">Search Tree</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Root node</code>는 <code class="language-plaintext highlighter-rouge">start state</code>이고 자녀는 후계자에 해당된다.</li>
  <li><code class="language-plaintext highlighter-rouge">Node</code>가 <code class="language-plaintext highlighter-rouge">state</code>를 표시하지만 이러한 <code class="language-plaintext highlighter-rouge">state</code>를 달성하는 계획에 해당된다.</li>
  <li>대부분의 문제에서 우리는 절대 <code class="language-plaintext highlighter-rouge">tree</code> 전체를 만들 수 없습니다.</li>
</ul>

<h3 id="state-space-graphs-vs-search-trees">State Space Graphs vs Search Trees</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">search tree</code>의 각 <code class="language-plaintext highlighter-rouge">node</code>는 <code class="language-plaintext highlighter-rouge">state space graph</code>의 전체 경로이다.</li>
  <li>우리는 필요에 따라 <code class="language-plaintext highlighter-rouge">tree</code>를 만들고, 가능한 한 적게 만듭니다.</li>
</ul>

<h3 id="depth-first-search">Depth-First Search</h3>
<ul>
  <li>Strategy: expand a a deepest node first</li>
  <li>Implementation: Frontier is a LIFO stack</li>
  <li><strong>Properties</strong> with depth <code class="language-plaintext highlighter-rouge">m</code> tree
    <ul>
      <li>time : $O(bm)$</li>
      <li>space : $O(b^m)$</li>
      <li>Is it complete?
        <ul>
          <li>m could be infinite, so only if we prevent cycles (more later)</li>
        </ul>
      </li>
      <li>Is it optimal?
        <ul>
          <li>No, it finds the “leftmost” solution</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="breath-frist-search">Breath-Frist Search</h3>
<ul>
  <li>Strategy: expand a shallowest node first</li>
  <li>Implementation: Fringe is a FIFO queue</li>
  <li><strong>Properties</strong> with depth <code class="language-plaintext highlighter-rouge">m</code>, shallowest solution’s depth <code class="language-plaintext highlighter-rouge">s</code> tree
    <ul>
      <li>time : $O(b^s)$</li>
      <li>space : $O(b^m)$</li>
      <li>Is it complete?
        <ul>
          <li>Yes, s must be finite if a solution exists</li>
        </ul>
      </li>
      <li>Is it optimal?
        <ul>
          <li>If costs are equal</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="uniform-cost-search">Uniform Cost Search</h3>
<ul>
  <li>Strategy: expand a cheapest node first:</li>
  <li>Implementation: Fringe is a priority queue (priority: cumulative cost)</li>
  <li><strong>Properties</strong> with depth <code class="language-plaintext highlighter-rouge">m</code>, solution costs $C^*$ and arcs cost at least $\epsilon$
    <ul>
      <li>time : $O(b^{C^*/\epsilon})$</li>
      <li>space : $O(b^m)$</li>
      <li>Is it complete?
        <ul>
          <li>Yes, Assuming best solution has a finite cost and minimum arc cost is positive</li>
        </ul>
      </li>
      <li>Is it optimal?
        <ul>
          <li>Yes</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Explores options in every “direction”</li>
  <li>No information about goal location</li>
</ul>]]></content><author><name>Junhwan</name></author><category term="ComputerScience" /><category term="AI" /><category term="COSE361" /><summary type="html"><![CDATA[용어 정리 strategy : 전략 complete : solution이 하나 존재 할 때 그 solution을 찾는 것이 보장되어 있는가? optimal : 최단 경로(the least cost path)를 찾는 것이 보장되어 있는가?]]></summary></entry><entry><title type="html">[수리통계학] Multivariate Probability Distributions</title><link href="http://localhost:4000/statistics/5-Multivariate-Probability-Distributions/" rel="alternate" type="text/html" title="[수리통계학] Multivariate Probability Distributions" /><published>2022-03-07T00:00:00+09:00</published><updated>2022-03-07T00:00:00+09:00</updated><id>http://localhost:4000/statistics/5%20Multivariate%20Probability%20Distributions</id><content type="html" xml:base="http://localhost:4000/statistics/5-Multivariate-Probability-Distributions/"><![CDATA[<h1 id="5-multivariate-probability-distributions">5 Multivariate Probability Distributions</h1>

<hr />

<h2 id="56-special-theorems">5.6 Special Theorems</h2>

<h3 id="theorem-56">THEOREM 5.6</h3>
<blockquote>
  <p>Let $c$ be a constant. Then
\(E(c) = c.\)</p>
</blockquote>

<h3 id="theorem-57">THEOREM 5.7</h3>
<blockquote>
  <p>Let $g(Y1,Y2)$ be a function of the random variables $Y1$ and $Y2$ and let $c$ be a constant. Then
\(E[cg(Y1, Y2)] = cE[g(Y1, Y2)].\)</p>
</blockquote>

<h3 id="theorem-58">THEOREM 5.8</h3>
<blockquote>
  <p>Let $Y1$ and $Y2$ be random variables and $g_1(Y_1,Y_2),\ g_2(Y_1,Y_2),\ \cdots,\ g_k(Y_1,Y_2)$ be functions of $Y_1$ and $Y_2$. Then
\(E[g_1(Y_1,Y_2)\ +\ g2(Y_1,Y_2)\ +\ ···\ +\ g_k(Y_1,Y_2)]
= E[g_1(Y_1,Y_2)]+ E[g_2(Y_1,Y_2)]+\ ···\ +\ E[g_k(Y_1,Y_2)].\)</p>
</blockquote>

<h3 id="theorem-59">THEOREM 5.9</h3>
<blockquote>
  <p>Let $Y_1$ and $Y_2$ be independent random variables and $g(Y_1)$ and $h(Y_2)$ be functions of only $Y_1$ and $Y_2$, respectively. Then
\(E[g(Y_1)h(Y_2)] = E[g(Y_1)]E[h(Y_2)],\)
provided that the expectations exist.</p>
</blockquote>

<hr />

<h2 id="57-the-covariance-of-two-random-variables">5.7 The Covariance of Two Random Variables</h2>

<h3 id="definition-510">DEFINITION 5.10</h3>
<blockquote>
  <p>If $Y_1$ and $Y_2$ are random variables with means $μ_1$ and $μ_2$, respectively, the covariance of $Y_1$ and $Y_2$ is
\(Cov(Y_1, Y_2) = E [(Y_1 − μ_1)(Y_2 − μ_2)] .\)</p>
</blockquote>

<h3 id="theorem-510">THEOREM 5.10</h3>
<blockquote>
  <p>If $Y_1$ and $Y_2$ are random variables with means $μ_1$ and $μ_2$, respectively, then 
\(Cov(Y_1, Y_2) = E [(Y_1 − μ_1)(Y_2 − μ_2)] = E(Y_1Y_2) − E(Y_1)E(Y_2).\)</p>
</blockquote>

<h3 id="theorem-511">THEOREM 5.11</h3>
<blockquote>
  <p>If $Y_1$ and $Y_2$ are independent random variables, then 
\(Cov(Y_1, Y_2) = 0.\)
Thus, independent random variables must be uncorrelated.</p>
</blockquote>

<hr />

<h2 id="58-the-expected-value-and-variance-of-linear-functions-of-random-variables">5.8 The Expected Value and Variance of Linear Functions of Random Variables</h2>

<h3 id="theorem-512">THEOREM 5.12</h3>
<blockquote>
  <p>Let $Y_1,Y_2,…,Y_n$ and $X_1, X_2,…, X_m$ be random variables with $E(Y_i) = μ_i$ and $E ( X_j ) = ξ_j$. Define
\(U_1=\sum^{n}_{i=1}a_iY_i\quad and\quad  U_2=\sum^{n}_{j=1}b_jX_j\)
for constants $a_1,a_2,…,a_n$ and $b_1,b_2,…,b_m.$ Then the following hold:</p>

  <p><strong>a</strong>    $E(U_1)= \sum^n_{i=1}a_iμ_i.$</p>

  <p><strong>b</strong>    $V(U_1) = \sum^n_{i=1} a_i^2V(Y_i) + 2\sum\sum_{ 1≤i&lt;j≤n} a_ia_jCov(Y_i,Y_j)$, where the double sum is over all pairs $(i, j)$ with $i &lt; j$.</p>

  <p><strong>c</strong>    $Cov(U_1,U_2)=\sum_{i=1}^n\sum_{j=1}^m a_ib_jCov(Y_i,X_j)$.</p>
</blockquote>]]></content><author><name>Junhwan</name></author><category term="Statistics" /><category term="MathematicalStatistics" /><category term="STAT232" /><summary type="html"><![CDATA[5 Multivariate Probability Distributions]]></summary></entry><entry><title type="html">[수리통계학] Continuous Variables and Their Probability Distributions</title><link href="http://localhost:4000/statistics/4-Continuous-Variables-and-Their-Probability-Distributions/" rel="alternate" type="text/html" title="[수리통계학] Continuous Variables and Their Probability Distributions" /><published>2022-03-06T00:00:00+09:00</published><updated>2022-03-06T00:00:00+09:00</updated><id>http://localhost:4000/statistics/4%20Continuous%20Variables%20and%20Their%20Probability%20Distributions</id><content type="html" xml:base="http://localhost:4000/statistics/4-Continuous-Variables-and-Their-Probability-Distributions/"><![CDATA[<h1 id="4-continuous-variables-and-their-probability-distributions">4 Continuous Variables and Their Probability Distributions</h1>

<hr />

<h2 id="42-the-probability-distribution-for-a-continuous-random-variable">4.2 The Probability Distribution for a Continuous Random Variable</h2>

<h3 id="definition-41">DEFINITION 4.1</h3>
<blockquote>
  <p>Let $Y$ denote any random variable. The distribution function of $Y$ , denoted by $F(y)$, is such that $F(y) = P(Y ≤ y)$ for $−∞ &lt; y &lt; ∞.$</p>
</blockquote>

<h3 id="theorem-41">THEOREM 4.1</h3>
<blockquote>
  <p>Let Y denote any random variable. The distribution function of $Y$, denoted by $F(y)$, is such that $F(y) = P(Y ≤ y)$ for $−∞ &lt; y &lt; ∞.$</p>
</blockquote>

<h3 id="definition-42">DEFINITION 4.2</h3>
<blockquote>
  <p>A random variable $Y$ with distribution function $F(y)$ is said to be continuous if $F(y)$ is continuous, for $−∞ &lt; y &lt; ∞.$</p>
</blockquote>

<h3 id="definition-43">DEFINITION 4.3</h3>
<blockquote>
  <p>Let $F(y)$ be the distribution function for a continuous random variable $Y$. Then $f(y)$, given by
$f(y)= dF(y)= {dF^′(y) \over dy}$
wherever the derivative exists, is called the probability density function for the random variable $Y$ .</p>
</blockquote>

<h3 id="theorem-42">THEOREM 4.2</h3>
<blockquote>
  <p><strong>Properties of a Density Function</strong> If $f(y)$ is a density function for a continuous random variable, then</p>
  <ol>
    <li>$f(y) ≥ 0$ for all $y$, $−∞&lt;y&lt;∞.$</li>
    <li>$\int_{-∞}^{∞} f(y)dy=1.$</li>
  </ol>
</blockquote>

<h3 id="definition-44">DEFINITION 4.4</h3>
<blockquote>
  <p>Let $Y$ denote any random variable. If $0 &lt; p &lt; 1$, the $p$th <strong><em>quantile</em></strong> of $Y$, denoted by $\phi_p$, is the smallest value such that $P(Y ≤ \phi_p) = F(\phi_p) ≥ p.$ If $Y$ is continuous, $\phi_p$ is the smallest value such that $F(\phi_p) = P(Y ≤ \phi_p) = p.$ Some prefer to call $\phi_p$ the $100p$th percentile of Y.</p>
</blockquote>

<h3 id="theorem-43">THEOREM 4.3</h3>
<blockquote>
  <p>If the random variable $Y$ has density function $f (y)$ and $a &lt; b$, then the probability that $Y$ falls in the interval $[a, b]$ is
\(P(a ≤ Y ≤ b) = \int_{a}^{b}f (y) dy.\)</p>
</blockquote>

<hr />

<h2 id="43-expected-values-for-continuous-random-variables">4.3 Expected Values for Continuous Random Variables</h2>

<h3 id="definition-45">DEFINITION 4.5</h3>
<blockquote>
  <p>The expected value of a continuous random variable $Y$ is 
\(E(Y) =\int_{-∞}^{∞}yf(y)\ dy\) 
provided that the integral exists.</p>
</blockquote>

<h3 id="theroem-44">THEROEM 4.4</h3>
<blockquote>
  <p>Let $g(Y )$ be a function of $Y$ ; then the expected value of $g(Y )$ is given by 
\(E [g(Y )] = \int_{-∞}^{∞}g(y)f(y)\ dy\)
provided that the integral exists.</p>
</blockquote>

<h3 id="theorem-45">THEOREM 4.5</h3>
<blockquote>
  <p>Let $c$ be a constant and let $g(Y), g_1(Y), g_2(Y),…,g_k(Y)$ be functions of a continuous random variable $Y$ . Then the following results hold:</p>
  <ol>
    <li>$E(c) = c.$</li>
    <li>$E[cg(Y)] = cE[g(Y)].$</li>
    <li>$E[g_1(Y)+g_2(Y)+···+gk(Y)] = E[g_1(Y)]+E[g_2(Y)]+···+E[g_k(Y)].$</li>
  </ol>
</blockquote>]]></content><author><name>Junhwan</name></author><category term="Statistics" /><category term="MathematicalStatistics" /><category term="STAT232" /><summary type="html"><![CDATA[4 Continuous Variables and Their Probability Distributions]]></summary></entry><entry><title type="html">[수리통계학] Discrete Random Variables and Their Probability Distributions</title><link href="http://localhost:4000/statistics/3-Discrete-Random-Variables-and-Their-Probability-Distributions/" rel="alternate" type="text/html" title="[수리통계학] Discrete Random Variables and Their Probability Distributions" /><published>2022-03-05T00:00:00+09:00</published><updated>2022-03-05T00:00:00+09:00</updated><id>http://localhost:4000/statistics/3%20Discrete%20Random%20Variables%20and%20Their%20Probability%20Distributions</id><content type="html" xml:base="http://localhost:4000/statistics/3-Discrete-Random-Variables-and-Their-Probability-Distributions/"><![CDATA[<h1 id="3-discrete-random-variables-and-their-probability-distributions">3 Discrete Random Variables and Their Probability Distributions</h1>

<hr />

<h2 id="31-basic-definition">3.1 Basic DEFINITION</h2>
<h3 id="definition-31">DEFINITION 3.1</h3>
<blockquote>
  <p>A random variable <strong><em>Y</em></strong> is said to be <em><strong>discrete</strong></em> if it can assume only a finite or countably infinite number of distinct values</p>
</blockquote>

<p>랜덤 변수 $Y$는 finite하거나 countably infinite한 고유 값만 가정할 수 있는 경우 $discrete$라고 한다.</p>

<h4 id="countably-infinite">Countably infinite</h4>
<blockquote>
  <p>A set is countably infinite if its elements can be put in one-to-one correspondence with the set of natural numbers.</p>
</blockquote>

<p>원소들이 자연수들의 집합과 일대일 대응에 놓일 수 있다면 그 집합은 countably infinite하다.</p>

<p>Countably infinite하다는 것은 우리가 영원히 셀 수 없을 정도로 큰 집합을 설명하는 것과 대조적이다. finite sets을 포함하지 않는 다는 것을 강조할 때 사용한다.</p>

<hr />

<h2 id="32-the-probability-distribution-for-a-discrete-random-variable">3.2 The Probability Distribution for a Discrete Random Variable</h2>

<h3 id="definition-32">DEFINITION 3.2</h3>
<blockquote>
  <p>The probability that $Y$ takes on the value $y$, $P(Y = y)$, is defined as the sum of the probabilities of all sample points in S that are assigned the value y. We will sometimes denote $P(Y = y)$ by $p(y)$.</p>
</blockquote>

<p>$Y$가 $y$를 값으로 가질 확률 $P(Y = y)$는 $y$를 값으로 가지는 모든 표본점의 확률의 합으로 정의된다.</p>

<h4 id="sample-point-표본점">sample point (표본점)</h4>
<blockquote>
  <p>a single possible observed value of a variable.
변수가 가질 수 있는 단일 관측치</p>
</blockquote>

<h3 id="definition-33">DEFINITION 3.3</h3>
<blockquote>
  <p><em>The probability distribution</em> for a discrete variable $Y$ can be represented by a formula, a table, or a graph that provides $p(y) = P(Y = y)$ for all $y$.</p>
</blockquote>

<p>이산형 변수 $Y$에 대한 확률 분포는 모든 Y에 대해 $p(y) = P(Y = y)$를 규정하는 공식, 표 또는 그래프로 나타낼 수 있다.</p>

<h3 id="theorem-31">THEOREM 3.1</h3>
<blockquote>
  <p>For any discrete probability distribution, the following must be true:</p>
  <ol>
    <li>$0≤ p(y)≤1$ for all $y$.</li>
    <li>$\sum_y p(y) = 1$, where the summation is over all values of $y$ with nonzero probability</li>
  </ol>
</blockquote>

<hr />

<h2 id="33-the-expected-value-of-a-random-variable-or-a-function-of-a-random-variable">3.3 The Expected Value of a Random Variable or a Function of a Random Variable</h2>

<h3 id="dfinition-34">Dfinition 3.4</h3>
<blockquote>
  <p>Let $Y$ be a discrete random variable with the probability function $p(y)$. Then the expected value of $Y$ , $E(Y)$, is defined to be
\(E(Y)=\sum yp(y).\)</p>
</blockquote>

<h3 id="theorem-32">THEOREM 3.2</h3>
<blockquote>
  <p>Let $Y$ be a discrete random variable with probability function $p(y)$ and $g(Y)$ be a real-valued function of $Y$. Then the expected value of $g(Y)$ is given by
\(E[g(Y)] = \sum_{all\ y} g(y)p(y).\)</p>
</blockquote>

<h3 id="definition-35">DEFINITION 3.5</h3>
<blockquote>
  <p>If $Y$ is a random variable with mean $E(Y) = μ$, the variance of a random variable $Y$ is defined to be the expected value of $(Y − μ)^2$. That is,
\(V (Y) = E [(Y − μ)^2].\)
The <em>standard deviation</em> of $Y$ is the positive square root of $V (Y )$.</p>
</blockquote>

<h3 id="theorem-33">THEOREM 3.3</h3>
<blockquote>
  <p>Let $Y$ be a discrete random variable with probability function $p(y)$ and c be a constant. Then $E(c) = c$.</p>
</blockquote>

<h3 id="theorem-34">THEOREM 3.4</h3>
<blockquote>
  <p>Let $Y$ be a discrete random variable with probability function $p(y)$, $g(Y)$ be a function of $Y$ , and c be a constant. Then
\(E[cg(Y)] = cE[g(Y)].\)</p>
</blockquote>

<h3 id="theorem-35">THEOREM 3.5</h3>
<blockquote>
  <p>Let $Y$ be a discrete random variable with probability function $p(y)$ and $g_1(Y ), g_2(Y),…, g_k(Y)$ be $k$ functions of $Y$. Then
\(E [g_1 (Y ) + g_2 (Y ) + · · · + g_k (Y )] = E [g_1 (Y )] + E [g_2 (Y )] + · · · + E [g_k (Y )].\)</p>
</blockquote>

<h3 id="theotem-36">THEOTEM 3.6</h3>
<blockquote>
  <p>Let $Y$ be a discrete random variable with probability function $p(y)$ and mean $E(Y) = μ$; then
\(V(Y)=σ^2 = E[(Y −μ)^2]= E(Y^2)−μ^2.\)</p>
</blockquote>

<hr />
<h2 id="34-the-binomial-probability-distribution">3.4 The Binomial Probability Distribution</h2>

<h3 id="definition-36">DEFINITION 3.6</h3>
<blockquote>
  <p>A binomial experiment possesses the following properties:</p>
  <ol>
    <li>The experiment consists of a fixed number, $n$, of identical trials.</li>
    <li>Each trial results in one of two outcomes: success, $S$, or failure, $F$.</li>
    <li>The probability of success on a single trial is equal to some value $p$ and remains the same from trial to trial. The probability of a failure is equal to $q = (1 − p)$.</li>
    <li>The trials are independent.</li>
    <li>The random variable of interest is $Y$ , the number of successes observed during the $n$ trials.</li>
  </ol>
</blockquote>

<p>이항 실험의 특성</p>

<ol>
  <li>실험은  고정된 n개의 동일한 시행으로 구성된다.</li>
  <li>각 시행의 결과는 성공, $S$ 또는 실패, $F$의 두 가지 결과 중 하나이다.</li>
  <li>각 시행에서 에서 성공할 확률은 어떤 값 $p$와 같다.같은 시행에서 실패 확률은 $q = (1 - p).$ 이다.</li>
  <li>각 시행은 독립이다.</li>
  <li>관심 랜덤 변수는 Y이며, $n$개의 시행 중 관찰된 성공 횟수입니다.</li>
</ol>

<h3 id="definition-37">DEFINITION 3.7</h3>
<blockquote>
  <p>A random variable $Y$ is said to have a binomial distribution based on n trials with success probability p if and only if
\(p(y)= {n\choose y}p^yq^{n−y},\qquad  y=0,1,2,...,\ n\ and\ 0≤p≤1.\)</p>
</blockquote>

<h3 id="theorem-37">THEOREM 3.7</h3>
<blockquote>
  <p>Let $Y$ be a binomial random variable based on $n$ trials and success probability $p$. Then
\(μ=E(Y)=np\quad and\quad σ^2 =V(Y)=npq.\)</p>
</blockquote>

<hr />

<h2 id="35-the-geometric-probability-distribution">3.5 The Geometric Probability Distribution</h2>

<h3 id="definition-38">DEFINITION 3.8</h3>
<blockquote>
  <p>A random variable $Y$ is said to have a geometric probability distribution if and only if
\(p(y)=q^{y−1}p,\quad y=1,2,3,...,\quad 0≤p≤1.\)</p>
</blockquote>

<h3 id="theorem-38">THEOREM 3.8</h3>
<blockquote>
  <p>If $Y$ is a random variable with a geometric distribution,
\(μ=E(Y)={1\over p} \quad and \quad σ^2=V(Y)={1−p \over p^2}.\)</p>
</blockquote>

<h2 id="36-the-negative-binomial-probability-distribution">3.6 The Negative Binomial Probability Distribution</h2>

<h3 id="definition-39">DEFINITION 3.9</h3>
<blockquote>
  <p>A random variable Y is said to have a <strong><em>negative binomial probability distribution</em></strong> if and only if
\(p(y)= {y-1\choose r-1}p^r q^{y−r},\quad  y=r,r+1,r+2,..., 0≤p≤1.\)</p>
</blockquote>

<h3 id="theorem-39">THEOREM 3.9</h3>
<blockquote>
  <p>If Y is a random variable with a negative binomial distribution,
\(μ=E(Y)= {r \over p}\quad and\quad σ^2=V(Y)= {r(1−p) \over p^2}.\)</p>
</blockquote>]]></content><author><name>Junhwan</name></author><category term="Statistics" /><category term="MathematicalStatistics" /><category term="STAT232" /><summary type="html"><![CDATA[3 Discrete Random Variables and Their Probability Distributions]]></summary></entry></feed>