<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-05-02T04:00:20+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Slow and Steady</title><subtitle>Data Science, Computer Science, Statistics, AI.</subtitle><author><name>Junhwan</name></author><entry><title type="html">[AL] 3. Fundamentals of the Analysis of Algorithm Efficiency</title><link href="http://localhost:4000/computerscience/AL-3-Fundamentals-of-the-Analysis-of-Algorithm-Efficiency/" rel="alternate" type="text/html" title="[AL] 3. Fundamentals of the Analysis of Algorithm Efficiency" /><published>2022-05-01T00:00:00+09:00</published><updated>2022-05-01T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/%5BAL%5D%203%20Fundamentals%20of%20the%20Analysis%20of%20Algorithm%20Efficiency</id><content type="html" xml:base="http://localhost:4000/computerscience/AL-3-Fundamentals-of-the-Analysis-of-Algorithm-Efficiency/"><![CDATA[<h2 id="efficiency">Efficiency</h2>
<ul>
  <li>시간 효율성 (시간 복잡도) : 문제에서 알고리즘이 얼마나 빨리 실행되를 의미한다.</li>
  <li>공간 효율성 (공간 복잡도) : 입출력에 필요한 공간 외에 알고리즘에 필요한 메모리 단위의 양을 의미한다.
현재 일반적으로 알고리즘에 필요한 추가 공간의 양은 크게 중요하지 않다. 대부분의 문제에서 공간보다 속도에서 훨씬 더 눈부신 발전을 이룰 수 있다.</li>
</ul>

<h2 id="time-efficiency">Time efficiency</h2>

<h3 id="measuring-an-algorithms-running-time">Measuring an algorithm’s running time</h3>
<ul>
  <li>프로그램의 실행시간 측정
    <ul>
      <li>특정 컴퓨터의 속도에 의존</li>
      <li>알고리즘을 구현하는 프로그램의 성능과 기계 코드를 생성하는 데 사용되는 컴파일러의 성능에 의존된다.</li>
      <li>프로그램의 실제 실행 시간을 측정하는 것은 어렵다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">basic operation</code>이 실행되는 횟수를 세는 방법
    <ul>
      <li>알고리즘의 <code class="language-plaintext highlighter-rouge">basic operation</code>을 확인하고 이것이 실행되는 횟수를 계산한다.</li>
      <li><code class="language-plaintext highlighter-rouge">Basic operation</code> : 총 실행 시간에 가장 많이 기여하는 작업 (일반적으로 일고리즘의 가장 안쪽 루프에서 가장 시간이 많이 걸리는 작업)
        <ul>
          <li>Example
            <ul>
              <li>정렬 알고리즘에서의 <code class="language-plaintext highlighter-rouge">key comparision</code></li>
              <li>수학적 문제에서의 사칙연산</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="tn">$T(n)$</h3>

<p>$n$ : input size, $T(n)$ : running time,  $c_{op}$ : execution time for basic operation, $C(n)$ : Number of times basic operation is executed
\(T(n) \approx c_{op}C(n)\)</p>

<h3 id="efficiency-on-particular-input">Efficiency on particular input</h3>
<ul>
  <li>특정 입력에 따라 효율성이 달라지는 알고리즘이 있다.
    <ul>
      <li>Sequencial search</li>
    </ul>
  </li>
  <li>The worst-case efficiency $C_{worst}(n)$
    <ul>
      <li>크기가 <code class="language-plaintext highlighter-rouge">n</code>인 모든 입력 중 가장 느리게 실행회는 worst-case의 efficiency.</li>
      <li>크기가 <code class="language-plaintext highlighter-rouge">n</code>인 입력에 대해 실행시간이 $C_{worst}(n)$를 초과하지 않음을 보장한다.</li>
    </ul>
  </li>
  <li>The best-case efficiency $C_{best}(n)$
    <ul>
      <li>크기가 <code class="language-plaintext highlighter-rouge">n</code>인 모든 입력 중 가장 빠르게 실행되는 best-case의 efficiency.</li>
      <li>best-case efficiency에 대한 분석은 worst-case efficiency에 대한 분석만큼 중요하진 않지만 완전히 쓸모 없는 것은 아니다.</li>
    </ul>
  </li>
  <li>The average-case efficiency $C_{avg}(n)$
    <ul>
      <li>average-case efficiency는 best-case 및 worst-case의 efficiency 조사보다 상당히 어렵다.</li>
    </ul>
  </li>
</ul>

<h4 id="sequencial-search">Sequencial search</h4>
<p>Pseudo code</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algorithm SequentialSearch(A[0..n-1], K)
    i &lt;- 0
        while i&lt;n and A[i]!=K do
            i &lt;- i+1
    if i &lt; n return i
    else return -1

</code></pre></div></div>

<ul>
  <li>$C_{worst}(n) = n$</li>
  <li>$C_{best}(n) = 1$</li>
  <li>$C_{avg}(n)$
    <ul>
      <li>$\sum_{i=1}^{n}({p \over n}i)+n(1-p) =  {p(n+1) \over 2}+n(1-p)$</li>
      <li>if $p=1$, $C_{avg}(n) = {n+1 \over 2}$</li>
      <li>if $p=0$, $C_{avg}(n) = n$</li>
    </ul>
  </li>
</ul>

<h3 id="asymptotic-order-of-growth">Asymptotic order of growth</h3>
<h4 id="ogn">$O(g(n))$</h4>
<p>$g(n)$보다 작거나 같은 증가율 가진 함수들의 집합</p>
<p>
	<img src="/assets/img/%5BAL%5D3/bigO.png" alt="kingdom" width="70%" height="70%" />
</p>

\[t(n) \in O(g(n))\]

\[^\exists c&gt;0 \quad s.t. \quad t(n) \le cg(n) \ for \ all \ n \ge n_0\]

<h4 id="omegagn">$\Omega(g(n))$</h4>
<p>$g(n)$보다 크거나 같은 증가율 합수들의 집합</p>

<p>
	<img src="/assets/img/%5BAL%5D3/bigOmega.png" alt="kingdom" width="70%" height="70%" />
</p>
<p>\(t(n) \in \Omega(g(n))\)</p>

\[^\exists c &gt;0 \quad s.t. \quad t(n) \ge cg(n) \quad for \ \  all \ \  n \ge n_0\]

<h4 id="thetagn">$\Theta(g(n))$</h4>
<p>
	<img src="/assets/img/%5BAL%5D3/bigTheta.png" alt="kingdom" width="70%" height="70%" />
</p>

<p>$g(n)$과 같은 증가율을 가진 함수들의 집합</p>

\[t(n) \in \Theta(g(n))\]

\[^\exists c_1, \ c_2&gt;0 \quad s.t. \quad  c_1g(n) \le t(n) \le c_2g(n) \quad for \ \  all \ \  n \ge n_0\]

<h4 id="using-limits-for-comparing-orders-of-grouth">Using limits for comparing orders of grouth</h4>

\[\lim_{n\rightarrow \infty}=\begin{cases}0\quad implies\ that\ t(n)\ has \ a\ smaller\ order\ of\ growth\ than\ g(n)\\c \quad implies\ that\ t(n)\ has \ the\ same\ order\ of\ growth\ as\ g(n) \\\infty \quad implies\ that\ t(n)\ has \ a\ larger\ order\ of\ growth\ as\ g(n) \end{cases}\]

<ul>
  <li>첫번째 두 경우는 $t(n) \in O(g(n))$을 의미한다</li>
  <li>마지막 두 경우는  $t(n) \in \Omega(g(n))$을 의미한다</li>
  <li>두번째 경우는  $t(n) \in \Theta(g(n))$을 의미한다</li>
</ul>

<h3 id="nonrecursive-algorithms">Nonrecursive algorithms</h3>

<h4 id="example-1-maximum-element">Example 1: Maximum element</h4>
<ul>
  <li>Pseudo code
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ALGORITHM MaxElement(A[0...n-1])
      maxval &lt;- A[0]
      for i &lt;- 1 to n-1 do
          maxval &lt;- A[i]
      return maxval
</code></pre></div>    </div>
  </li>
  <li>Input size : the numver of elements in the array, n</li>
  <li>Basic operation : comparison</li>
  <li>
\[C(n) = \sum^{n-1}_{i=1}1=n-1\in\Theta(n)\]
  </li>
</ul>

<h4 id="example-2-element-uniqueness-problem">Example 2: Element uniqueness problem</h4>
<ul>
  <li>Pseudo code
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ALGORITHM UniqueElements(A[0...n-1])
      for i &lt;- 0 to n-2 do
          for j &lt;- i+1 to n-1 do
              if A[i] = A[j] return false
      return true
</code></pre></div>    </div>
  </li>
  <li>Input size : the numver of elements in the array, n</li>
  <li>Basic operation : comparison</li>
  <li>The worst cases:
    <ul>
      <li>배열에 같은 원소가 없는 경우</li>
      <li>마지막 두 원소가 같은 경우
\(C_{worst}(n) = \sum^{n-2}_{i=0}\sum_{j=i+1}^{n-1}1=\sum^{n-2}_{i=0}(n-i-1)={n(n-1)\over2}\approx{1\over2}n^2\in\Theta(n^2)\)</li>
    </ul>
  </li>
</ul>

<h4 id="example-3-matrix-multiplication">Example 3: Matrix multiplication</h4>
<p align="center">
	<img src="/assets/img/%5BAL%5D3/matrix.png" alt="kingdom" width="70%" height="70%" />
</p>
<ul>
  <li>Pseudo code
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ALGORITHM MatrixMultiblication(A[0...n-1])
      for i &lt;- 0 to n-1 do
          for j &lt;- 0 to n-1 do
              C[i,j] &lt;- 0.0
              for k &lt;- 0 to n-1 do
                  C[i,j] &lt;- C[i,j] + A[i,k]*B[k,j]
      return C
</code></pre></div>    </div>
  </li>
  <li>Input size : the numver of elements in the array, n</li>
  <li>Basic operation : multiplication and addition</li>
</ul>

<center>$$M(n) = \sum^{n-1}_{i=0}\sum^{n-1}_{j=0}\sum^{n-1}_{k=0}= \sum^{n-1}_{i=0}\sum^{n-1}_{j=0}n=\sum^{n-1}_{i=0}n^2=n^3$$
$$T(n) \approx c_mM(n)+c_aM(n)=(c_m+c_a)n^3$$</center>

<h4 id="example-4-counting-binary-digits">Example 4: Counting binary digits</h4>
<ul>
  <li>Pseudo code
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ALGORITHM Binary(n)
      count &lt;- 1
      while n&gt;1 do
          count &lt;- count+1
          n &lt;- ⌊n/2⌋
      return count
</code></pre></div>    </div>
  </li>
  <li>Basic operation : comparison</li>
  <li>The total number of comparison : $\lfloor \log_2n\rfloor+1$</li>
</ul>

<h3 id="recursive-algorithms">Recursive algorithms</h3>

<h4 id="example-1-maximum-element-1">Example 1: Maximum element</h4>
<ul>
  <li>Pseudo code
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ALGORITHM F(n)
      if n=0 return 1
      else return F(n-1) * n
</code></pre></div>    </div>
  </li>
  <li>Input size : n</li>
  <li>Basic operation : multiplication
\(M(n) = M(n-1) + 1 \quad  for \quad n&gt;0,\quad M(0) =0\)
\(M(n) = M(n-1) + 1 =\ \cdots\ = M(n-n)+n=n\)</li>
</ul>

<h4 id="example-2-tower-of-hanoi-puzzle">Example 2: Tower of Hanoi puzzle</h4>
<p><img src="/assets/img/%5BAL%5D3/hanoi.png" alt="hanoi" width="70%" height="70%" /></p>
<ul>
  <li>Input size : the number of disks, n</li>
  <li>Basic operation : moving one disk</li>
</ul>

<p>\(M(n) = 2M(n-1) + 1 \quad  for \quad n&gt;1, \quad M(1)=1\)
\(M(n) = 2M(n-1) + 1 = 2[2M(n-2) + 1]+1 =\ \cdots\ = 2^{n-1}M(n-(n-1))+2^{n-1}-1=2^n-1\)</p>

<h4 id="example-3-counting-binary-digits-recursion">Example 3: Counting binary digits (recursion)</h4>
<ul>
  <li>Pseudo code
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ALGORITHM BinRec(n)
      if n=1 return 1
      else return BinRec(⌊n/2⌋)+1
</code></pre></div>    </div>
  </li>
  <li>The total number of additions : $A(n)$</li>
  <li>Recurrence : $A(n) = A(\lfloor {n\over2} \rfloor ) + 1$ for $n&gt;1$</li>
  <li>Initial condition: $A(1)=0$</li>
  <li>Smoothness rule</li>
</ul>

\[n=2^k\quad\quad\]

\[A(2^k)=A(2^{k-1})+1\quad for\quad k&gt;0,\quad A(2^0)=0\]

\[A(2^k) = A(2^{k-k})+k = A(1) + k = k\]

\[n=2^k,\quad k=\log_2n\]

\[A(n) = \log_2n\in\Theta(\log n)\]

<h4 id="example-4-computing-the-nth-fibonacci-number">Example 4: Computing the nth Fibonacci number</h4>
<ul>
  <li>Pseudo code
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ALGORITHM F(n)
      if n&lt;=1 return n
      else return F(n-1) + F(n-2)
</code></pre></div>    </div>
  </li>
  <li>Basic operation : addition</li>
  <li>The total number of additions : $A(n)$
    <ul>
      <li>
        <p>$A(2^k)=A(n-1)+A(n-2)+1\quad for\quad n&gt;1$</p>

        <p>$A(0)=0,\quad A(1)=0$</p>

        <p>$A(n) - A(n-1)-A(n-2)=1$</p>

        <p>$[A(n)+1]-[A(n-1)+1]-[A(n-2)+1]=0$</p>

        <p>$B(n) = A(n)+1$</p>

        <p>$B(n) - B(n-1)-B(n-2)=0,\quad B(0)=1,\quad B(1)=1$</p>

        <p>$B(n)={1\over \sqrt5}(\phi ^{n+1} - \hat\phi^{n+1} )$</p>

        <p>$A(n)={1\over \sqrt5}(\phi ^{n+1} - \hat\phi^{n+1} )-1 \in\Theta(\phi^n)$</p>
      </li>
    </ul>
  </li>
  <li>$\Theta(\log n)$ algorithm
    <ul>
      <li>\(\left[\begin{matrix}F(n-1) &amp; F(n) \\ F(n) &amp; F(n+1)\end{matrix}\right] = \left[ \begin{matrix}0&amp;1\\1&amp;1\end{matrix}\right]^n\)
for $n\ge1$</li>
    </ul>
  </li>
</ul>]]></content><author><name>Junhwan</name></author><category term="ComputerScience" /><category term="algorithm" /><category term="CSE214" /><summary type="html"><![CDATA[Efficiency 시간 효율성 (시간 복잡도) : 문제에서 알고리즘이 얼마나 빨리 실행되를 의미한다. 공간 효율성 (공간 복잡도) : 입출력에 필요한 공간 외에 알고리즘에 필요한 메모리 단위의 양을 의미한다. 현재 일반적으로 알고리즘에 필요한 추가 공간의 양은 크게 중요하지 않다. 대부분의 문제에서 공간보다 속도에서 훨씬 더 눈부신 발전을 이룰 수 있다.]]></summary></entry><entry><title type="html">[AL] 2. Important problem types</title><link href="http://localhost:4000/computerscience/AL-2-Important-problem-types/" rel="alternate" type="text/html" title="[AL] 2. Important problem types" /><published>2022-04-30T00:00:00+09:00</published><updated>2022-04-30T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/%5BAL%5D%202%20Important%20problem%20types</id><content type="html" xml:base="http://localhost:4000/computerscience/AL-2-Important-problem-types/"><![CDATA[<h2 id="sorting">Sorting</h2>
<h3 id="sorting을--하는-이유">Sorting을  하는 이유</h3>
<ul>
  <li>정렬이 출력으로 요구되는 작업이 있다.
    <ul>
      <li>ex) ranking</li>
    </ul>
  </li>
  <li>정렬은 리스트에 대한 질문에 쉽게 대답할 수 있게 해준다
    <ul>
      <li>ex) searching</li>
    </ul>
  </li>
  <li>정렬은 다른 분야의 중요한 알고리즘의 보조 단계로 사용된다.
    <ul>
      <li>ex) geometric algorithms and data compression</li>
    </ul>
  </li>
</ul>

<h3 id="sorting-알고리즘의-예">Sorting 알고리즘의 예</h3>
<ul>
  <li>Selection sort</li>
  <li>Bubble sort</li>
  <li>Insertion sort</li>
  <li>Merge sort</li>
  <li>Heap sort</li>
  <li>…
Sorting 알고리즘의 복잡성은 key의 비교 횟수로 평가한다.</li>
</ul>

<h3 id="sorting-알고리즘의-속성">Sorting 알고리즘의 속성</h3>
<p><code class="language-plaintext highlighter-rouge">stable</code> : 입력에서의 동일한 두 요소의 상대적인 순서가 바뀌지 않는 경우
<code class="language-plaintext highlighter-rouge">in place</code> : 적은 메모리 단위를 제외한 추가 메모리를 사용하지 않는 경우</p>

<h3 id="selection-sort">Selection Sort</h3>
<p>Input : array <code class="language-plaintext highlighter-rouge">a[1]</code>,…,<code class="language-plaintext highlighter-rouge">a[n]</code></p>

<p>Output :  array a sorted in non-decreasing order</p>

<p>Algorithm:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i=1 to n 
    swap a[i] with smallest of a[i],…,a[n] 
</code></pre></div></div>
<p>Pseudocode</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algorithm SelectionSort(A[0..n-1])
//The algorithm sorts a given array by selection sort
//Input: An array A[0..n-1] of orderable elements
//Output: Array A[0..n-1] sorted in ascending order
for i  0 to n – 2 do
	min  i
	for j  i + 1 to n – 1 do
		if A[j] &lt; A[min] 	
			min  j
	swap A[i] and A[min]
</code></pre></div></div>

<h2 id="searching">Searching</h2>
<ul>
  <li>
    <p>주어진 집합(또는 여러 요소가 동일한 값을 가질 수 있도록 허용된 다중 집합)에서 주어진 <code class="language-plaintext highlighter-rouge">search key</code>를 찾는다.</p>
  </li>
  <li>
    <p>Example</p>
    <ul>
      <li>Sequentail search</li>
      <li>Binary search</li>
    </ul>
  </li>
</ul>

<h2 id="string-processing">String processing</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">string</code>: character 배열</li>
  <li><code class="language-plaintext highlighter-rouge">Text strings</code>: letters, numbers, and special characters.</li>
  <li><code class="language-plaintext highlighter-rouge">String matching</code>: 글에서 주어진 단어나 패턴을 검색</li>
</ul>

<h2 id="graph-problems">Graph problems</h2>
<ul>
  <li>실제 문제 모델링
    <ul>
      <li>World Wide Web(WWW) 모델링</li>
      <li>통신망 모델링</li>
      <li>프로젝트 스케줄링</li>
    </ul>
  </li>
  <li>기본적인 그래프 알고리즘
    <ul>
      <li>그래프 순회 알고리즘</li>
      <li>최단거리 알고리즘</li>
      <li>위상정렬</li>
    </ul>
  </li>
</ul>

<h2 id="combinational-problems">Combinational problems</h2>
<ul>
  <li>명시적으로나 암묵적으로 순열, 조합, 부분집합과 같은 <code class="language-plaintext highlighter-rouge">combinatorial object</code>를 찾는것을 요청</li>
  <li>ex) traveling salesman problem (TSP)
    <ul>
      <li>N개 도시를 모두 정확히 한 번 방문하는 최단 기간 찾기</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Combinational</code> 문제는 이론적 및 실제적 관점에서 컴퓨팅에서 가장 어려운 문제이다.</li>
  <li><code class="language-plaintext highlighter-rouge">combinatorial object</code>의 수는 일반적으로 문제의 크기에 따라 매우 빠르게 증가한다.</li>
  <li>제한된 시간안에 정확하게 푸는 알려진 알고리즘이 없다.</li>
</ul>

<h2 id="geometric-problems">Geometric problems</h2>
<ul>
  <li>점, 선, 다각형과 같은 <code class="language-plaintext highlighter-rouge">geometric object</code>를 다룬다.
    <ul>
      <li>응용 : 컴퓨터 그래픽, 로보틱스, 단층 촬영</li>
    </ul>
  </li>
  <li>Example
    <ul>
      <li>The closest-pair problem</li>
      <li>The convex-hull problem</li>
    </ul>
  </li>
</ul>

<h2 id="numerical-problems">Numerical problems</h2>
<ul>
  <li>연속적인 <code class="language-plaintext highlighter-rouge">mathematical objects</code>를 포함하는 문제이다.</li>
  <li>이러한 대부분의 수학적 문제들은 근사적으로만 풀 수 있다.</li>
  <li>근사된 숫자에 대해 산술 연산을 많이 수행하면 반올림 오차가 누적되어 크게 왜곡될 수 있다.</li>
  <li>Example
    <ul>
      <li>방정식</li>
      <li>연립방적식</li>
      <li>정적분</li>
      <li>함수값 계산</li>
    </ul>
  </li>
</ul>]]></content><author><name>Junhwan</name></author><category term="ComputerScience" /><category term="algorithm" /><category term="CSE214" /><summary type="html"><![CDATA[Sorting Sorting을 하는 이유 정렬이 출력으로 요구되는 작업이 있다. ex) ranking 정렬은 리스트에 대한 질문에 쉽게 대답할 수 있게 해준다 ex) searching 정렬은 다른 분야의 중요한 알고리즘의 보조 단계로 사용된다. ex) geometric algorithms and data compression]]></summary></entry><entry><title type="html">[AL] 1. Intro</title><link href="http://localhost:4000/computerscience/AL-1.-Intro/" rel="alternate" type="text/html" title="[AL] 1. Intro" /><published>2022-04-30T00:00:00+09:00</published><updated>2022-04-30T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/%5BAL%5D%201.%20Intro</id><content type="html" xml:base="http://localhost:4000/computerscience/AL-1.-Intro/"><![CDATA[<h2 id="algorithm을-공부해야하는-이유">Algorithm을 공부해야하는 이유</h2>

<h3 id="컴퓨터-전문가가-되려고-하는-학생이라면">컴퓨터 전문가가 되려고 하는 학생이라면</h3>
<ul>
  <li>실용적인 이유
    <ul>
      <li>다양한 컴퓨팅 분야의 중요한 Algorithm의 표준적인 집합을 알아야한다.</li>
      <li>새로운 Algorithm을 디자인하고 효율성을 분석할 수 있어야 한다.</li>
    </ul>
  </li>
  <li>이론적인 이유
    <ul>
      <li>algorithmics은 컴퓨터 과학의 기반이다.</li>
    </ul>
  </li>
</ul>

<h3 id="computing-related-학생이-아니라면">computing-related 학생이 아니라면</h3>
<ul>
  <li>Algorithm이 없는 컴퓨터 프로그램은 존재하지 않는다.</li>
  <li>컴퓨터 어플리케이션이 우리의 직업적, 개인적인 삶의 거의 모든 면에서 필수불가결해지면서, Algorithm을 공부하는 것은 점점 더 많은 사람들에게 필수가 됨</li>
</ul>

<p><strong>Algorithm을 공부하는 것은 분석 기술을 기르는데 유용하다.</strong></p>

<h2 id="what-is-an-algorithm">What is an algorithm</h2>

<p>An algorithm is a sequence of unambiguous instructions for solving a problem, i.e., for obtaining a required output for any legitimate input in a finite amount of time.</p>

<p>Algorithm은 문제를 해결하기 위한 명확한 명령의 연속이다. 즉, 제한된 시간 내에 모든 허용된 입력에 필요한 출력을 얻기 위한 것이다.</p>

<h2 id="algorithm의-특징">Algorithm의 특징</h2>
<p>The nonambiguity requirement for each step of an algorithm cannot be compromised.</p>

<p>각 단계는 애매하지 않아야한다.</p>

<p>The range of inputs for which an algorithm works has to be specified carefully.</p>

<p>Algorithm이 작동하는 입력의 범위가 구체적으로 명시 되어야한다.</p>

<p>The same algorithm can be represented in several different ways.</p>

<p>같은 Algorithm은 여러 방법으로 표현될 수 있다.</p>

<p>There may exist several algorithms for solving the same problem.</p>

<p>같은 문제를 푸는 Algorithm은 다양하게 존재할 수 있다.</p>

<p>Algorithms for the same problem can be based on very different ideas and can solve the problem with dramatically different speeds.</p>

<p>같은 문제의 Algorithm은 매우 다른 아이디어에 기반될 수 있고 문제를 푸는 속도가 많이 차이날 수 있다.</p>

<h2 id="algorithm의-성질">Algorithm의 성질</h2>
<ul>
  <li>Finiteness
    <ul>
      <li>terminates after a finite number of steps</li>
      <li>유한한 개수의 명령 후에 끝이 나야한다.</li>
    </ul>
  </li>
  <li>Definiteness
    <ul>
      <li>rigorously and unambiguously specified</li>
      <li>엄격해야하고 중의적이지 않아야한다.</li>
    </ul>
  </li>
  <li>Clearly specified input
    <ul>
      <li>valid inputs are clearly specified</li>
      <li>입력이 명확하게 명시되어야한다.</li>
    </ul>
  </li>
  <li>Clearly specified/expected output
    <ul>
      <li>can be proved to produce the correct output given a valid input</li>
      <li>유효한 입력이 주어졌을 때 정확한 출력을 만들어 냈는지 증명할 수 있어야한다.</li>
    </ul>
  </li>
  <li>Effectiveness
    <ul>
      <li>steps are sufficiently simple and basic</li>
      <li>각 단계가 충분히 간단하고 기본적이어야한다.</li>
    </ul>
  </li>
</ul>

<h2 id="최대공약수-구하기">최대공약수 구하기</h2>
<h3 id="유클리드-algorithm">유클리드 Algorithm</h3>
<p><strong>Eclid’s algorithm</strong> for computing <code class="language-plaintext highlighter-rouge">gcd(m,n)
**Step 1** 만약 </code>n=0<code class="language-plaintext highlighter-rouge"> 이면 정답으로 </code>m<code class="language-plaintext highlighter-rouge">을 리턴하고 멈춘다.; 아니라면 **Step 2**를 진행한다.
**Step 2** </code>m<code class="language-plaintext highlighter-rouge">을 </code>n<code class="language-plaintext highlighter-rouge">으로 나눈 나머지를 </code>r<code class="language-plaintext highlighter-rouge">에 할당한다.
**Step 3** </code>n<code class="language-plaintext highlighter-rouge">을 </code>m<code class="language-plaintext highlighter-rouge">에 할당하고 </code>r<code class="language-plaintext highlighter-rouge">을 </code>n`에 할당한 뒤 <strong>Step 1</strong>로 돌아간다.</p>

<p>pseudo code</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//Inputs: Two nonegative, not-both-zero integers m and n
//OUtput: Greatest common divisor of m and n
Euclid(m,n)
  while n!=0 do
    r = m mod n
    m = n
    n = r
  return m
</code></pre></div></div>

<h3 id="consecutive-integer-checking-algorithm">Consecutive integer checking algorithm</h3>
<p><strong>Step 1</strong> <code class="language-plaintext highlighter-rouge">t</code>에 <code class="language-plaintext highlighter-rouge">min(m.n)</code>을 할당한다 
<strong>Step 2</strong> <code class="language-plaintext highlighter-rouge">m</code>을 <code class="language-plaintext highlighter-rouge">t</code>로 나누고 나머지가 <code class="language-plaintext highlighter-rouge">0</code>이라면 <strong>Step 3</strong>로 가고 아니면 <strong>Step 4</strong>로 간다.
<strong>Step 3</strong> <code class="language-plaintext highlighter-rouge">n</code>을 <code class="language-plaintext highlighter-rouge">t</code>로 나누고 나머지가 <code class="language-plaintext highlighter-rouge">0</code>이라면 <code class="language-plaintext highlighter-rouge">t</code>를 정답으로 리턴하고 멈춘다. 아니라면 <strong>Step 4</strong>로 간다.
<strong>Step 4</strong> <code class="language-plaintext highlighter-rouge">t</code>를 1 감소시키고 <strong>Step 2</strong>로 간다.</p>

<p>이 Algorithm은 입력값이 0일 때 제대로 작동하지 않는다.</p>

<h3 id="소인수-분해">소인수 분해</h3>
<p><strong>Step 1</strong> <code class="language-plaintext highlighter-rouge">m</code>을 소인수를 찾아라
<strong>Step 2</strong> <code class="language-plaintext highlighter-rouge">n</code>을 소인수를 찾아라
<strong>Step 3</strong> <strong>Step 1</strong>과 <strong>Step 2</strong>에서 공통으로 나오는 소인수를 찾아라
<strong>Step 4</strong> 모두 곱해라</p>

<p>소인수 분해를 하는 방법이 unambiguously하게 정의되어 있지 않아 좋은 Algorithm 기술방법이 아니다.</p>

<h3 id="understanding-the-problem">Understanding the problem</h3>
<ul>
  <li>Algorithm을 디자인하기 전 첫번째로 해야하는 것은 주어진 문제를 충분히 이해하는 것이다.
    <ul>
      <li>문제 설명을 조심스럽게 읽는다.</li>
      <li>문제에 대해 조금이라도 의문이 있다면 질문한다.</li>
      <li>손으로 몇가지 작은 예시들을 풀어본다</li>
      <li>특이 케이스를 생각해본다.</li>
      <li>필요하다면 다시 질문해본다.</li>
    </ul>
  </li>
  <li>컴퓨터 응용프로그램에서 자주 발생하는 몇가지 문제들이 있다.
    <ul>
      <li>이런 문제라면 이미 알려진 Algorithm을 사용한다.</li>
      <li>사용 가능한 Algorithm을 찾지 못하면 직접 디자인한다.</li>
    </ul>
  </li>
  <li>
    <p>정확한 Algorithm은 대부분 잘 작동하는 것이 아닌 허용된 모든 입력에 대해 제대로 작동해야한다.
이 단계를 건너 뛴다면 불필요한 작업을 다시해야할 위험이 있다.</p>
  </li>
  <li>디바이스의 능력을 확인해야한다.
    <ul>
      <li>많은 상황에서 작업이 느려지는 것에 대해 걱정하지 않아도 된다.</li>
      <li>하지만 복잡한 문제이거나 거대한 양의 데이터를 작업해야하거나 시간이 큰 영향을 미치는 상황에선 이것은 중요한 문제이다.</li>
    </ul>
  </li>
</ul>

<h3 id="choosing-between-exact-and-approximate-problem-solving">Choosing between Exact and Approximate Problem Solving</h3>
<p>Approximation algorithm을 선택하는 경우</p>
<ol>
  <li>대부분의 경우에서 정확하게 해결할 수 없는 중요한 문제들이 있다.
Ex) 제곱근 구하기, 비선형 방정식 해결 및 유한 적분 계산</li>
  <li>문제를 정확하게 해결하기 위해 사용할 수 있는 Algorithm은 문제의 본질적인 복잡성 때문에 굉장히 느릴 수 있다.
    <ul>
      <li>이것은 특히, 매우 많은 수의 선택과 관련된 많은 문제들에서 발생한다.</li>
    </ul>
  </li>
  <li>근사 Algorithm은 문제를 정확하게 해결하는 Algorithm보다 정교한 Algorithm의 일부가 될 수 있다.</li>
</ol>

<h3 id="algorithm-실계-전략">Algorithm 실계 전략</h3>
<p>Algorithm 디자인 기술(전략)은 문제를 다양한 컴퓨팅 분야의 다양한 문제에 적용할 수 있는 Algorithm 방식으로 해결하기 위한 일반적인 접근이다.</p>

<h3 id="algorithm과-자료-구조-디자인">Algorithm과 자료 구조 디자인</h3>
<p>Algorithm 디자인 기술은 Algorithm 문제 해결에 대한 강력한 일반 접근 방식을 제공하지만,</p>
<ul>
  <li>특정 문제에 대한 Algorithm을 디자인하는 것은 여전히 ​​어려운 작업일 수 있다.</li>
  <li>일부 디자인 기술은 해당 문제에 단순히 적용할 수 없다.</li>
  <li>때로는 여러 기술을 결합해야 하며 알려진 디자인 기술의 적용으로 정확히 지적하기 어려운 Algorithm이 있다.</li>
</ul>

<p>Algorithm이 수행하는 작업에 적합한 데이터 구조를 선택하는 데 세심한 주의를 기울여야 한다.</p>
<ul>
  <li>Algorithm + 데이터 구조 = 프로그램 [Wir76]</li>
</ul>

<h3 id="algorithm을-표현하는-방법">Algorithm을 표현하는 방법</h3>
<ul>
  <li>natural language (자연어)</li>
  <li>Pesudocode
    <ul>
      <li>자연어와 프로그래밍 언어를 섞은 형태</li>
    </ul>
  </li>
  <li>Flowchart
    <ul>
      <li>복잡한 Algorithm엔 사용하기 어려워 잘 쓰이지 않는다.</li>
    </ul>
  </li>
</ul>

<h3 id="algorithm-correctness-증명">Algorithm Correctness 증명</h3>
<p>모든 허용된 입력에 대하여 제한된 시간안에 필요한 결과를 얻을 수 있는지 증명해야한다.
이 증명은 쉬운 경우도 있고 복잡한 경우도 있다.</p>

<h3 id="algorithm-분석">Algorithm 분석</h3>
<ul>
  <li>Efficiency
    <ul>
      <li>time : 얼마나 빠른지</li>
      <li>space : 메모리를 얼마나 사용하는지</li>
    </ul>
  </li>
  <li>Simplicity
    <ul>
      <li>더욱 간단한 Algorithm은 프로그램하기와 이해하기가 쉽고 가끔 더 효율적이다.</li>
    </ul>
  </li>
  <li>Generality
위의 것들을 만족하지 않으면 다시 디자인해야한다.</li>
</ul>

<h3 id="coding-an-algorithm">Coding an Algorithm</h3>
<p>대부분의 알고리즘의 궁극적인 목적은 컴퓨터 프로그램으로 구현되는 것이다.
알고리즘에서 프로그램으로 잘못 또는 매우 비효율적으로 변환될 위험성이 있다.
실질적인 문제로서, 프로그램의 유효성은 여전히 테스트를 통해 확립된다.
알고리즘을 구현할 때마다 프로그램을 철저히 테스트하고 디버깅해야한다.</p>

<p>일반적으로, 좋은 알고리즘은 반복적인 노력과 재작업의 결과이다.</p>]]></content><author><name>Junhwan</name></author><category term="ComputerScience" /><category term="algorithm" /><category term="CSE214" /><summary type="html"><![CDATA[Algorithm을 공부해야하는 이유]]></summary></entry><entry><title type="html">[AI] Uniformed Search</title><link href="http://localhost:4000/computerscience/1-Uniformed-Search/" rel="alternate" type="text/html" title="[AI] Uniformed Search" /><published>2022-04-24T00:00:00+09:00</published><updated>2022-04-24T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/1%20Uniformed%20Search</id><content type="html" xml:base="http://localhost:4000/computerscience/1-Uniformed-Search/"><![CDATA[<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>용어 정리
strategy : 전략
complete : solution이 하나 존재 할 때 그 solution을 찾는 것이 보장되어 있는가?
optimal : 최단 경로(the least cost path)를 찾는 것이 보장되어 있는가?   
</code></pre></div></div>

<h1 id="uniformed-search">Uniformed Search</h1>
<h2 id="agents">Agents</h2>
<h3 id="rational-agents">Rational agents</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Rational agent</code>는 명확한 선호도를 가지고 기대치를 통해 불확실성을 모델링하고, 모든 실행 가능한 행동 중 항상 자신에게 최적의 결과를 가져오도록 행동을 수행하도록 선택하는 agent이다.
    <h3 id="reflex-agents">Reflex agents</h3>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Reflex agent</code>s는 현재 상태에 기반을 두어 다음 <code class="language-plaintext highlighter-rouge">action</code>을 선택하는 <code class="language-plaintext highlighter-rouge">agent</code>로 이 Action이 가져올 미래에 대해 고려하지 않는다.</li>
</ul>

<h3 id="planning-agents">Planning agents</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Planning agents</code>는 (가설화된) <code class="language-plaintext highlighter-rouge">sequences of action</code>에 기반을 두어 결정한다.</li>
  <li><code class="language-plaintext highlighter-rouge">World</code>가 <code class="language-plaintext highlighter-rouge">action</code>에 대응하여 어떻게 변해가는지에 대한 모델을 가지고 있다.</li>
</ul>

<h2 id="search">Search</h2>
<h3 id="search-problem">Search Problem</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Search Problem</code>은 <code class="language-plaintext highlighter-rouge">state space</code>(상태 공간), <code class="language-plaintext highlighter-rouge">successor function</code>(후계 함수 action, cost 포함), <code class="language-plaintext highlighter-rouge">start state</code> (시작 상태) 및 <code class="language-plaintext highlighter-rouge">goal test</code>로 구성된다.</li>
  <li>솔루션은 <code class="language-plaintext highlighter-rouge">start state</code>(시작 상태)를 <code class="language-plaintext highlighter-rouge">goal state</code>(목표 상태)로 변환하는 <code class="language-plaintext highlighter-rouge">sequenc of action</code>(plan)이다.</li>
</ul>

<h3 id="state-space-graph">State Space Graph</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">State space graph</code>는 <code class="language-plaintext highlighter-rouge">search problem</code>의 수학적 표현이다. <code class="language-plaintext highlighter-rouge">Node</code>들은 <code class="language-plaintext highlighter-rouge">state</code>를, <code class="language-plaintext highlighter-rouge">arcs</code>는 <code class="language-plaintext highlighter-rouge">action</code>을 나타내며 이것이 가르키는 <code class="language-plaintext highlighter-rouge">node</code>는 그 <code class="language-plaintext highlighter-rouge">action</code>의 결과이다.</li>
  <li>Search graph에서 각 state는 한 번씩 등장한다.</li>
  <li>전체 그래프는 매우 크기 때문에 메모리에 거의 만들 수 없지만 유용한 아이디어이다.</li>
</ul>

<h3 id="search-tree">Search Tree</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Root node</code>는 <code class="language-plaintext highlighter-rouge">start state</code>이고 자녀는 후계자에 해당된다.</li>
  <li><code class="language-plaintext highlighter-rouge">Node</code>가 <code class="language-plaintext highlighter-rouge">state</code>를 표시하지만 이러한 <code class="language-plaintext highlighter-rouge">state</code>를 달성하는 계획에 해당된다.</li>
  <li>대부분의 문제에서 우리는 절대 <code class="language-plaintext highlighter-rouge">tree</code> 전체를 만들 수 없습니다.</li>
</ul>

<h3 id="state-space-graphs-vs-search-trees">State Space Graphs vs Search Trees</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">search tree</code>의 각 <code class="language-plaintext highlighter-rouge">node</code>는 <code class="language-plaintext highlighter-rouge">state space graph</code>의 전체 경로이다.</li>
  <li>우리는 필요에 따라 <code class="language-plaintext highlighter-rouge">tree</code>를 만들고, 가능한 한 적게 만듭니다.</li>
</ul>

<h3 id="depth-first-search">Depth-First Search</h3>
<ul>
  <li>Strategy: expand a a deepest node first</li>
  <li>Implementation: Frontier is a LIFO stack</li>
  <li><strong>Properties</strong> with depth <code class="language-plaintext highlighter-rouge">m</code> tree
    <ul>
      <li>time : $O(bm)$</li>
      <li>space : $O(b^m)$</li>
      <li>Is it complete?
        <ul>
          <li>m could be infinite, so only if we prevent cycles (more later)</li>
        </ul>
      </li>
      <li>Is it optimal?
        <ul>
          <li>No, it finds the “leftmost” solution</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="breath-frist-search">Breath-Frist Search</h3>
<ul>
  <li>Strategy: expand a shallowest node first</li>
  <li>Implementation: Fringe is a FIFO queue</li>
  <li><strong>Properties</strong> with depth <code class="language-plaintext highlighter-rouge">m</code>, shallowest solution’s depth <code class="language-plaintext highlighter-rouge">s</code> tree
    <ul>
      <li>time : $O(b^s)$</li>
      <li>space : $O(b^m)$</li>
      <li>Is it complete?
        <ul>
          <li>Yes, s must be finite if a solution exists</li>
        </ul>
      </li>
      <li>Is it optimal?
        <ul>
          <li>If costs are equal</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="uniform-cost-search">Uniform Cost Search</h3>
<ul>
  <li>Strategy: expand a cheapest node first:</li>
  <li>Implementation: Fringe is a priority queue (priority: cumulative cost)</li>
  <li><strong>Properties</strong> with depth <code class="language-plaintext highlighter-rouge">m</code>, solution costs $C^*$ and arcs cost at least $\epsilon$
    <ul>
      <li>time : $O(b^{C^*/\epsilon})$</li>
      <li>space : $O(b^m)$</li>
      <li>Is it complete?
        <ul>
          <li>Yes, Assuming best solution has a finite cost and minimum arc cost is positive</li>
        </ul>
      </li>
      <li>Is it optimal?
        <ul>
          <li>Yes</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Explores options in every “direction”</li>
  <li>No information about goal location</li>
</ul>]]></content><author><name>Junhwan</name></author><category term="ComputerScience" /><category term="AI" /><category term="COSE361" /><summary type="html"><![CDATA[용어 정리 strategy : 전략 complete : solution이 하나 존재 할 때 그 solution을 찾는 것이 보장되어 있는가? optimal : 최단 경로(the least cost path)를 찾는 것이 보장되어 있는가?]]></summary></entry><entry><title type="html">[수리통계학] Multivariate Probability Distributions</title><link href="http://localhost:4000/statistics/5-Multivariate-Probability-Distributions/" rel="alternate" type="text/html" title="[수리통계학] Multivariate Probability Distributions" /><published>2022-03-07T00:00:00+09:00</published><updated>2022-03-07T00:00:00+09:00</updated><id>http://localhost:4000/statistics/5%20Multivariate%20Probability%20Distributions</id><content type="html" xml:base="http://localhost:4000/statistics/5-Multivariate-Probability-Distributions/"><![CDATA[<h1 id="5-multivariate-probability-distributions">5 Multivariate Probability Distributions</h1>

<hr />

<h2 id="56-special-theorems">5.6 Special Theorems</h2>

<h3 id="theorem-56">THEOREM 5.6</h3>
<blockquote>
  <p>Let $c$ be a constant. Then
\(E(c) = c.\)</p>
</blockquote>

<h3 id="theorem-57">THEOREM 5.7</h3>
<blockquote>
  <p>Let $g(Y1,Y2)$ be a function of the random variables $Y1$ and $Y2$ and let $c$ be a constant. Then
\(E[cg(Y1, Y2)] = cE[g(Y1, Y2)].\)</p>
</blockquote>

<h3 id="theorem-58">THEOREM 5.8</h3>
<blockquote>
  <p>Let $Y1$ and $Y2$ be random variables and $g_1(Y_1,Y_2),\ g_2(Y_1,Y_2),\ \cdots,\ g_k(Y_1,Y_2)$ be functions of $Y_1$ and $Y_2$. Then
\(E[g_1(Y_1,Y_2)\ +\ g2(Y_1,Y_2)\ +\ ···\ +\ g_k(Y_1,Y_2)]
= E[g_1(Y_1,Y_2)]+ E[g_2(Y_1,Y_2)]+\ ···\ +\ E[g_k(Y_1,Y_2)].\)</p>
</blockquote>

<h3 id="theorem-59">THEOREM 5.9</h3>
<blockquote>
  <p>Let $Y_1$ and $Y_2$ be independent random variables and $g(Y_1)$ and $h(Y_2)$ be functions of only $Y_1$ and $Y_2$, respectively. Then
\(E[g(Y_1)h(Y_2)] = E[g(Y_1)]E[h(Y_2)],\)
provided that the expectations exist.</p>
</blockquote>

<hr />

<h2 id="57-the-covariance-of-two-random-variables">5.7 The Covariance of Two Random Variables</h2>

<h3 id="definition-510">DEFINITION 5.10</h3>
<blockquote>
  <p>If $Y_1$ and $Y_2$ are random variables with means $μ_1$ and $μ_2$, respectively, the covariance of $Y_1$ and $Y_2$ is
\(Cov(Y_1, Y_2) = E [(Y_1 − μ_1)(Y_2 − μ_2)] .\)</p>
</blockquote>

<h3 id="theorem-510">THEOREM 5.10</h3>
<blockquote>
  <p>If $Y_1$ and $Y_2$ are random variables with means $μ_1$ and $μ_2$, respectively, then 
\(Cov(Y_1, Y_2) = E [(Y_1 − μ_1)(Y_2 − μ_2)] = E(Y_1Y_2) − E(Y_1)E(Y_2).\)</p>
</blockquote>

<h3 id="theorem-511">THEOREM 5.11</h3>
<blockquote>
  <p>If $Y_1$ and $Y_2$ are independent random variables, then 
\(Cov(Y_1, Y_2) = 0.\)
Thus, independent random variables must be uncorrelated.</p>
</blockquote>

<hr />

<h2 id="58-the-expected-value-and-variance-of-linear-functions-of-random-variables">5.8 The Expected Value and Variance of Linear Functions of Random Variables</h2>

<h3 id="theorem-512">THEOREM 5.12</h3>
<blockquote>
  <p>Let $Y_1,Y_2,…,Y_n$ and $X_1, X_2,…, X_m$ be random variables with $E(Y_i) = μ_i$ and $E ( X_j ) = ξ_j$. Define
\(U_1=\sum^{n}_{i=1}a_iY_i\quad and\quad  U_2=\sum^{n}_{j=1}b_jX_j\)
for constants $a_1,a_2,…,a_n$ and $b_1,b_2,…,b_m.$ Then the following hold:</p>

  <p><strong>a</strong>    $E(U_1)= \sum^n_{i=1}a_iμ_i.$</p>

  <p><strong>b</strong>    $V(U_1) = \sum^n_{i=1} a_i^2V(Y_i) + 2\sum\sum_{ 1≤i&lt;j≤n} a_ia_jCov(Y_i,Y_j)$, where the double sum is over all pairs $(i, j)$ with $i &lt; j$.</p>

  <p><strong>c</strong>    $Cov(U_1,U_2)=\sum_{i=1}^n\sum_{j=1}^m a_ib_jCov(Y_i,X_j)$.</p>
</blockquote>]]></content><author><name>Junhwan</name></author><category term="Statistics" /><category term="MathematicalStatistics" /><category term="STAT232" /><summary type="html"><![CDATA[5 Multivariate Probability Distributions]]></summary></entry><entry><title type="html">[수리통계학] Continuous Variables and Their Probability Distributions</title><link href="http://localhost:4000/statistics/4-Continuous-Variables-and-Their-Probability-Distributions/" rel="alternate" type="text/html" title="[수리통계학] Continuous Variables and Their Probability Distributions" /><published>2022-03-06T00:00:00+09:00</published><updated>2022-03-06T00:00:00+09:00</updated><id>http://localhost:4000/statistics/4%20Continuous%20Variables%20and%20Their%20Probability%20Distributions</id><content type="html" xml:base="http://localhost:4000/statistics/4-Continuous-Variables-and-Their-Probability-Distributions/"><![CDATA[<h1 id="4-continuous-variables-and-their-probability-distributions">4 Continuous Variables and Their Probability Distributions</h1>

<hr />

<h2 id="42-the-probability-distribution-for-a-continuous-random-variable">4.2 The Probability Distribution for a Continuous Random Variable</h2>

<h3 id="definition-41">DEFINITION 4.1</h3>
<blockquote>
  <p>Let $Y$ denote any random variable. The distribution function of $Y$ , denoted by $F(y)$, is such that $F(y) = P(Y ≤ y)$ for $−∞ &lt; y &lt; ∞.$</p>
</blockquote>

<h3 id="theorem-41">THEOREM 4.1</h3>
<blockquote>
  <p>Let Y denote any random variable. The distribution function of $Y$, denoted by $F(y)$, is such that $F(y) = P(Y ≤ y)$ for $−∞ &lt; y &lt; ∞.$</p>
</blockquote>

<h3 id="definition-42">DEFINITION 4.2</h3>
<blockquote>
  <p>A random variable $Y$ with distribution function $F(y)$ is said to be continuous if $F(y)$ is continuous, for $−∞ &lt; y &lt; ∞.$</p>
</blockquote>

<h3 id="definition-43">DEFINITION 4.3</h3>
<blockquote>
  <p>Let $F(y)$ be the distribution function for a continuous random variable $Y$. Then $f(y)$, given by
$f(y)= dF(y)= {dF^′(y) \over dy}$
wherever the derivative exists, is called the probability density function for the random variable $Y$ .</p>
</blockquote>

<h3 id="theorem-42">THEOREM 4.2</h3>
<blockquote>
  <p><strong>Properties of a Density Function</strong> If $f(y)$ is a density function for a continuous random variable, then</p>
  <ol>
    <li>$f(y) ≥ 0$ for all $y$, $−∞&lt;y&lt;∞.$</li>
    <li>$\int_{-∞}^{∞} f(y)dy=1.$</li>
  </ol>
</blockquote>

<h3 id="definition-44">DEFINITION 4.4</h3>
<blockquote>
  <p>Let $Y$ denote any random variable. If $0 &lt; p &lt; 1$, the $p$th <strong><em>quantile</em></strong> of $Y$, denoted by $\phi_p$, is the smallest value such that $P(Y ≤ \phi_p) = F(\phi_p) ≥ p.$ If $Y$ is continuous, $\phi_p$ is the smallest value such that $F(\phi_p) = P(Y ≤ \phi_p) = p.$ Some prefer to call $\phi_p$ the $100p$th percentile of Y.</p>
</blockquote>

<h3 id="theorem-43">THEOREM 4.3</h3>
<blockquote>
  <p>If the random variable $Y$ has density function $f (y)$ and $a &lt; b$, then the probability that $Y$ falls in the interval $[a, b]$ is
\(P(a ≤ Y ≤ b) = \int_{a}^{b}f (y) dy.\)</p>
</blockquote>

<hr />

<h2 id="43-expected-values-for-continuous-random-variables">4.3 Expected Values for Continuous Random Variables</h2>

<h3 id="definition-45">DEFINITION 4.5</h3>
<blockquote>
  <p>The expected value of a continuous random variable $Y$ is 
\(E(Y) =\int_{-∞}^{∞}yf(y)\ dy\) 
provided that the integral exists.</p>
</blockquote>

<h3 id="theroem-44">THEROEM 4.4</h3>
<blockquote>
  <p>Let $g(Y )$ be a function of $Y$ ; then the expected value of $g(Y )$ is given by 
\(E [g(Y )] = \int_{-∞}^{∞}g(y)f(y)\ dy\)
provided that the integral exists.</p>
</blockquote>

<h3 id="theorem-45">THEOREM 4.5</h3>
<blockquote>
  <p>Let $c$ be a constant and let $g(Y), g_1(Y), g_2(Y),…,g_k(Y)$ be functions of a continuous random variable $Y$ . Then the following results hold:</p>
  <ol>
    <li>$E(c) = c.$</li>
    <li>$E[cg(Y)] = cE[g(Y)].$</li>
    <li>$E[g_1(Y)+g_2(Y)+···+gk(Y)] = E[g_1(Y)]+E[g_2(Y)]+···+E[g_k(Y)].$</li>
  </ol>
</blockquote>]]></content><author><name>Junhwan</name></author><category term="Statistics" /><category term="MathematicalStatistics" /><category term="STAT232" /><summary type="html"><![CDATA[4 Continuous Variables and Their Probability Distributions]]></summary></entry><entry><title type="html">[수리통계학] Discrete Random Variables and Their Probability Distributions</title><link href="http://localhost:4000/statistics/3-Discrete-Random-Variables-and-Their-Probability-Distributions/" rel="alternate" type="text/html" title="[수리통계학] Discrete Random Variables and Their Probability Distributions" /><published>2022-03-05T00:00:00+09:00</published><updated>2022-03-05T00:00:00+09:00</updated><id>http://localhost:4000/statistics/3%20Discrete%20Random%20Variables%20and%20Their%20Probability%20Distributions</id><content type="html" xml:base="http://localhost:4000/statistics/3-Discrete-Random-Variables-and-Their-Probability-Distributions/"><![CDATA[<h1 id="3-discrete-random-variables-and-their-probability-distributions">3 Discrete Random Variables and Their Probability Distributions</h1>

<hr />

<h2 id="31-basic-definition">3.1 Basic DEFINITION</h2>
<h3 id="definition-31">DEFINITION 3.1</h3>
<blockquote>
  <p>A random variable <strong><em>Y</em></strong> is said to be <em><strong>discrete</strong></em> if it can assume only a finite or countably infinite number of distinct values</p>
</blockquote>

<p>랜덤 변수 $Y$는 finite하거나 countably infinite한 고유 값만 가정할 수 있는 경우 $discrete$라고 한다.</p>

<h4 id="countably-infinite">Countably infinite</h4>
<blockquote>
  <p>A set is countably infinite if its elements can be put in one-to-one correspondence with the set of natural numbers.</p>
</blockquote>

<p>원소들이 자연수들의 집합과 일대일 대응에 놓일 수 있다면 그 집합은 countably infinite하다.</p>

<p>Countably infinite하다는 것은 우리가 영원히 셀 수 없을 정도로 큰 집합을 설명하는 것과 대조적이다. finite sets을 포함하지 않는 다는 것을 강조할 때 사용한다.</p>

<hr />

<h2 id="32-the-probability-distribution-for-a-discrete-random-variable">3.2 The Probability Distribution for a Discrete Random Variable</h2>

<h3 id="definition-32">DEFINITION 3.2</h3>
<blockquote>
  <p>The probability that $Y$ takes on the value $y$, $P(Y = y)$, is defined as the sum of the probabilities of all sample points in S that are assigned the value y. We will sometimes denote $P(Y = y)$ by $p(y)$.</p>
</blockquote>

<p>$Y$가 $y$를 값으로 가질 확률 $P(Y = y)$는 $y$를 값으로 가지는 모든 표본점의 확률의 합으로 정의된다.</p>

<h4 id="sample-point-표본점">sample point (표본점)</h4>
<blockquote>
  <p>a single possible observed value of a variable.
변수가 가질 수 있는 단일 관측치</p>
</blockquote>

<h3 id="definition-33">DEFINITION 3.3</h3>
<blockquote>
  <p><em>The probability distribution</em> for a discrete variable $Y$ can be represented by a formula, a table, or a graph that provides $p(y) = P(Y = y)$ for all $y$.</p>
</blockquote>

<p>이산형 변수 $Y$에 대한 확률 분포는 모든 Y에 대해 $p(y) = P(Y = y)$를 규정하는 공식, 표 또는 그래프로 나타낼 수 있다.</p>

<h3 id="theorem-31">THEOREM 3.1</h3>
<blockquote>
  <p>For any discrete probability distribution, the following must be true:</p>
  <ol>
    <li>$0≤ p(y)≤1$ for all $y$.</li>
    <li>$\sum_y p(y) = 1$, where the summation is over all values of $y$ with nonzero probability</li>
  </ol>
</blockquote>

<hr />

<h2 id="33-the-expected-value-of-a-random-variable-or-a-function-of-a-random-variable">3.3 The Expected Value of a Random Variable or a Function of a Random Variable</h2>

<h3 id="dfinition-34">Dfinition 3.4</h3>
<blockquote>
  <p>Let $Y$ be a discrete random variable with the probability function $p(y)$. Then the expected value of $Y$ , $E(Y)$, is defined to be
\(E(Y)=\sum yp(y).\)</p>
</blockquote>

<h3 id="theorem-32">THEOREM 3.2</h3>
<blockquote>
  <p>Let $Y$ be a discrete random variable with probability function $p(y)$ and $g(Y)$ be a real-valued function of $Y$. Then the expected value of $g(Y)$ is given by
\(E[g(Y)] = \sum_{all\ y} g(y)p(y).\)</p>
</blockquote>

<h3 id="definition-35">DEFINITION 3.5</h3>
<blockquote>
  <p>If $Y$ is a random variable with mean $E(Y) = μ$, the variance of a random variable $Y$ is defined to be the expected value of $(Y − μ)^2$. That is,
\(V (Y) = E [(Y − μ)^2].\)
The <em>standard deviation</em> of $Y$ is the positive square root of $V (Y )$.</p>
</blockquote>

<h3 id="theorem-33">THEOREM 3.3</h3>
<blockquote>
  <p>Let $Y$ be a discrete random variable with probability function $p(y)$ and c be a constant. Then $E(c) = c$.</p>
</blockquote>

<h3 id="theorem-34">THEOREM 3.4</h3>
<blockquote>
  <p>Let $Y$ be a discrete random variable with probability function $p(y)$, $g(Y)$ be a function of $Y$ , and c be a constant. Then
\(E[cg(Y)] = cE[g(Y)].\)</p>
</blockquote>

<h3 id="theorem-35">THEOREM 3.5</h3>
<blockquote>
  <p>Let $Y$ be a discrete random variable with probability function $p(y)$ and $g_1(Y ), g_2(Y),…, g_k(Y)$ be $k$ functions of $Y$. Then
\(E [g_1 (Y ) + g_2 (Y ) + · · · + g_k (Y )] = E [g_1 (Y )] + E [g_2 (Y )] + · · · + E [g_k (Y )].\)</p>
</blockquote>

<h3 id="theotem-36">THEOTEM 3.6</h3>
<blockquote>
  <p>Let $Y$ be a discrete random variable with probability function $p(y)$ and mean $E(Y) = μ$; then
\(V(Y)=σ^2 = E[(Y −μ)^2]= E(Y^2)−μ^2.\)</p>
</blockquote>

<hr />
<h2 id="34-the-binomial-probability-distribution">3.4 The Binomial Probability Distribution</h2>

<h3 id="definition-36">DEFINITION 3.6</h3>
<blockquote>
  <p>A binomial experiment possesses the following properties:</p>
  <ol>
    <li>The experiment consists of a fixed number, $n$, of identical trials.</li>
    <li>Each trial results in one of two outcomes: success, $S$, or failure, $F$.</li>
    <li>The probability of success on a single trial is equal to some value $p$ and remains the same from trial to trial. The probability of a failure is equal to $q = (1 − p)$.</li>
    <li>The trials are independent.</li>
    <li>The random variable of interest is $Y$ , the number of successes observed during the $n$ trials.</li>
  </ol>
</blockquote>

<p>이항 실험의 특성</p>

<ol>
  <li>실험은  고정된 n개의 동일한 시행으로 구성된다.</li>
  <li>각 시행의 결과는 성공, $S$ 또는 실패, $F$의 두 가지 결과 중 하나이다.</li>
  <li>각 시행에서 에서 성공할 확률은 어떤 값 $p$와 같다.같은 시행에서 실패 확률은 $q = (1 - p).$ 이다.</li>
  <li>각 시행은 독립이다.</li>
  <li>관심 랜덤 변수는 Y이며, $n$개의 시행 중 관찰된 성공 횟수입니다.</li>
</ol>

<h3 id="definition-37">DEFINITION 3.7</h3>
<blockquote>
  <p>A random variable $Y$ is said to have a binomial distribution based on n trials with success probability p if and only if
\(p(y)= {n\choose y}p^yq^{n−y},\qquad  y=0,1,2,...,\ n\ and\ 0≤p≤1.\)</p>
</blockquote>

<h3 id="theorem-37">THEOREM 3.7</h3>
<blockquote>
  <p>Let $Y$ be a binomial random variable based on $n$ trials and success probability $p$. Then
\(μ=E(Y)=np\quad and\quad σ^2 =V(Y)=npq.\)</p>
</blockquote>

<hr />

<h2 id="35-the-geometric-probability-distribution">3.5 The Geometric Probability Distribution</h2>

<h3 id="definition-38">DEFINITION 3.8</h3>
<blockquote>
  <p>A random variable $Y$ is said to have a geometric probability distribution if and only if
\(p(y)=q^{y−1}p,\quad y=1,2,3,...,\quad 0≤p≤1.\)</p>
</blockquote>

<h3 id="theorem-38">THEOREM 3.8</h3>
<blockquote>
  <p>If $Y$ is a random variable with a geometric distribution,
\(μ=E(Y)={1\over p} \quad and \quad σ^2=V(Y)={1−p \over p^2}.\)</p>
</blockquote>

<h2 id="36-the-negative-binomial-probability-distribution">3.6 The Negative Binomial Probability Distribution</h2>

<h3 id="definition-39">DEFINITION 3.9</h3>
<blockquote>
  <p>A random variable Y is said to have a <strong><em>negative binomial probability distribution</em></strong> if and only if
\(p(y)= {y-1\choose r-1}p^r q^{y−r},\quad  y=r,r+1,r+2,..., 0≤p≤1.\)</p>
</blockquote>

<h3 id="theorem-39">THEOREM 3.9</h3>
<blockquote>
  <p>If Y is a random variable with a negative binomial distribution,
\(μ=E(Y)= {r \over p}\quad and\quad σ^2=V(Y)= {r(1−p) \over p^2}.\)</p>
</blockquote>]]></content><author><name>Junhwan</name></author><category term="Statistics" /><category term="MathematicalStatistics" /><category term="STAT232" /><summary type="html"><![CDATA[3 Discrete Random Variables and Their Probability Distributions]]></summary></entry><entry><title type="html">[용어정리] EDA</title><link href="http://localhost:4000/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC/EDA/" rel="alternate" type="text/html" title="[용어정리] EDA" /><published>2022-02-02T00:00:00+09:00</published><updated>2022-02-02T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC/EDA</id><content type="html" xml:base="http://localhost:4000/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC/EDA/"><![CDATA[<h1 id="exploratory-data-analysis-eda---탐색적-데이터-분석">Exploratory Data Analysis (EDA) - 탐색적 데이터 분석</h1>

<p>EDA는 데이터 분석을 위하기 위해 주로 데이터 시각화(graphic)을 사용하여 dataset에 대해 직관적인으로 이해 하는 과정</p>

<ol>
  <li>Dataset에 대한 통찰력을 극대화.</li>
  <li>기초 구조 확인</li>
  <li>중요 변수 추출</li>
  <li>특이치(outliers)와 이상치(anomalies)를 탐지</li>
  <li>기초적인 가정을 시험</li>
  <li>parsimonious models 개발</li>
  <li>최적 인자 설정</li>
</ol>

<h2 id="목적">목적</h2>

<p>dataset과 dataset의 기본 구조에 대한 통찰력을 극대화 시키는 것이다.</p>

<ul>
  <li>본격적인 데이터 분석에 들어가기 앞서 데이터의 수집을 결정할 수 있으다.</li>
  <li>다양한 각도에서 살펴보는 과정을 통해 문제 정의 단계에서 발견하지 못한 다양한 패턴을 발견할 수 있다.</li>
  <li>데이터 이해를 통해 적절한 통계 도구를 제시하고 추가적인 자료수집을 위한 기반이 된다.</li>
</ul>

<blockquote>
  <p>“<em>Exploratory data analysis is an attitude , a state of flexibility, a willingness to look for those things that we believe are not there, as well as those we believe to be there</em>”</p>

  <p>“ ‘탐색적 데이터 분석(EDA)’은 우리가 존재한다고 믿는 것들은 물론이고 존재하지 않는다고 믿는 것들을 발견하려는 태도, 유연성, 그리고 자발성이다. “</p>

  <p>-Jhon Turkey</p>
</blockquote>]]></content><author><name>Junhwan</name></author><category term="용어정리" /><category term="Statistics" /><summary type="html"><![CDATA[Exploratory Data Analysis (EDA) - 탐색적 데이터 분석 EDA는 데이터 분석을 위하기 위해 주로 데이터 시각화(graphic)을 사용하여 dataset에 대해 직관적인으로 이해 하는 과정 Dataset에 대한 통찰력을 극대화. 기초 구조 확인 중요 변수 추출 특이치(outliers)와 이상치(anomalies)를 탐지 기초적인 가정을 시험 parsimonious models 개발 최적 인자 설정 목적 dataset과 dataset의 기본 구조에 대한 통찰력을 극대화 시키는 것이다. 본격적인 데이터 분석에 들어가기 앞서 데이터의 수집을 결정할 수 있으다. 다양한 각도에서 살펴보는 과정을 통해 문제 정의 단계에서 발견하지 못한 다양한 패턴을 발견할 수 있다. 데이터 이해를 통해 적절한 통계 도구를 제시하고 추가적인 자료수집을 위한 기반이 된다. “Exploratory data analysis is an attitude , a state of flexibility, a willingness to look for those things that we believe are not there, as well as those we believe to be there” “ ‘탐색적 데이터 분석(EDA)’은 우리가 존재한다고 믿는 것들은 물론이고 존재하지 않는다고 믿는 것들을 발견하려는 태도, 유연성, 그리고 자발성이다. “ -Jhon Turkey]]></summary></entry></feed>